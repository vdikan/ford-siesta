<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
   
   <meta name="description" content="A first-principles materials simulation code using Density Functional Theory.">
    
    <meta name="author" content="SIESTA Group" >
    <link rel="icon" href="../favicon.png">

    <title>splitwload &ndash; SIESTA</title>

    <link href="../css/bootstrap.min.css" rel="stylesheet">
    <link href="../css/pygments.css" rel="stylesheet">
    <link href="../css/font-awesome.min.css" rel="stylesheet">
    <link href="../css/local.css" rel="stylesheet">
    
    

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!--[if lt IE 9]>
      <script src="https://oss.maxcdn.com/html5shiv/3.7.2/html5shiv.min.js"></script>
      <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
    
    <script src="../js/jquery-2.1.3.min.js"></script>
    <script src="../js/svg-pan-zoom.min.js"></script>

  </head>

  <body>

    <!-- Fixed navbar -->
    <nav class="navbar navbar-inverse navbar-fixed-top">
      <div class="container">
        <div class="navbar-header">
          <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar" aria-expanded="false" aria-controls="navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
          </button>
          <a class="navbar-brand" href="../index.html">SIESTA <small>trunk-700--vdikan-edens-704-ford-68</small></a>
        </div>
        <div id="navbar" class="navbar-collapse collapse">
          <ul class="nav navbar-nav">
        
            <li><a href='../page/index.html'>Program Overview</a></li>
      
            <li class="dropdown hidden-xs visible-sm visible-md hidden-lg">
              <a href="#" class="dropdown-toggle"
              data-toggle="dropdown" role="button"
              aria-haspopup="true"
     aria-expanded="false">Contents <span class="caret"></span></a>
        <ul class="dropdown-menu">
          
              
            <li><a href="../lists/files.html">Source Files</a></li>
        
        
        
            <li><a href="../lists/modules.html">Modules</a></li>
        
            
                                
            <li><a href="../lists/procedures.html">Procedures</a></li>
        
               
            <li><a href="../lists/types.html">Derived Types</a></li>
        
        
            </ul>
            </li>


<li class="visible-xs hidden-sm visible-lg"><a href="../lists/files.html">Source Files</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/modules.html">Modules</a></li>



<li class="visible-xs hidden-sm visible-lg"><a href="../lists/procedures.html">Procedures</a></li>

                             
<li class="visible-xs hidden-sm visible-lg"><a href="../lists/types.html">Derived Types</a></li>


          </ul>
        
        </div><!--/.nav-collapse -->
      </div>
    </nav>

    <div class="container">
    
  
  <div class="row">
    <h1>splitwload
      <small>Subroutine</small>
    
    </h1>
    
<div class="row">
  <div class="col-lg-12">
<div class="well well-sm">
  <ul class="list-inline" style="margin-bottom:0px;display:inline">
     
     
     
     
    
    
     <li><i class="fa fa-list-ol"></i>
       <a data-toggle="tooltip"
    data-placement="bottom" data-html="true"
    title=" 1.4% of total for procedures.">87 statements</a>
     </li> 
     
     
     
    <li><i class="fa fa-code"></i><a href="../src/moremeshsubs.F"> Source File</a></li>
     
     
  </ul>
  <ol class="breadcrumb in-well text-right">
  
    
     <li><a href='../sourcefile/moremeshsubs.f.html'>moremeshsubs.F</a></li>
    
     <li><a href='../module/moremeshsubs.html'>moreMeshSubs</a></li>
    
  
     <li class="active">splitwload</li>
  </ol>
</div>
</div>
</div>
<script>
  $(function () {
  $('[data-toggle="tooltip"]').tooltip()
  })
</script>

  </div>
  
  <div class="row">
    <div class="col-md-3 hidden-xs hidden-sm visible-md visible-lg">
    
<div id="sidebar">
  
<h3>Contents</h3>
 





















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../proc/splitwload.html#src">splitwload</a>
  </div>
</div>



</div>

    </div>
    
    <div class="col-md-9" id='text'>
    <h2>
private subroutine splitwload(Nodes, Node, nm, wload, iDistr, oDistr)
    
    
   
</h2>
    
  
    <div class="panel panel-default">
      <div class="panel-heading">
  <h3 class="panel-title">Uses</h3>
      </div>
      <ul class="list-group">
      
      <li class="list-group-item">
  <ul class="list-inline">
    
    <li>mpi_siesta</li>
    
  </ul>
      </li>
      
      
      
      </ul>
    </div>
    


    

    <h3>Arguments</h3>
    
      
<table class="table table-striped varlist">
<thead><tr><th>Type</th>
<th>Intent</th><th>Optional</th>
<th>Attributes</th><th></th><th>Name</th><th></th></thead>



<tbody>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nodes"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>Nodes</strong></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-node"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>Node</strong></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-nm%7E3"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>nm</strong>(3)</td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-wload%7E2"></span>integer,</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>wload</strong>(*)</td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-idistr%7E12"></span>type(<a href='../type/meshdistype.html'>meshDisType</a>),</td>
  <td>intent(in)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>iDistr</strong></td><td></td>
  
</tr>

  
  
  
  
<tr>
  
  <td><span class="anchor" id="variable-odistr%7E5"></span>type(<a href='../type/meshdistype.html'>meshDisType</a>),</td>
  <td>intent(out)</td>
  <td></td>
  
  <td></td><td>::</td>
  <td><strong>oDistr</strong></td><td></td>
  
</tr>

</tbody>
</table>

    
    
    
    
     
    <br>

    <section class="visible-xs visible-sm hidden-md">
      
<h3>Contents</h3>
 





















<div class="panel panel-primary">
  <div class="panel-heading text-left"><h3 class="panel-title">Source Code</h3></div>
  <div class="list-group">
    <a class="list-group-item" href="../proc/splitwload.html#src">splitwload</a>
  </div>
</div>



    </section>
    <br class="visible-xs visible-sm hidden-md">

    

    
    
    
    
    

    
    
    
    
    


    
    
    
    <section>
    <h2><span class="anchor" id="src"></span>Source Code</h2>
    <div class="highlight"><pre><span></span><span class="n">C</span> <span class="n">The</span> <span class="k">subroutine </span><span class="n">splitwload</span> <span class="n">will</span> <span class="k">return </span><span class="n">the</span> <span class="n">limits</span> <span class="n">of</span> <span class="n">the</span> <span class="n">new</span> <span class="k">data</span>
<span class="n">C</span> <span class="n">distribution</span><span class="p">.</span> <span class="n">The</span> <span class="k">subroutine </span><span class="n">compMeshComm</span> <span class="n">will</span> <span class="k">return </span><span class="n">the</span> <span class="n">communications</span>
<span class="n">C</span> <span class="n">needed</span> <span class="n">to</span> <span class="n">move</span> <span class="k">data </span><span class="n">from</span><span class="o">/</span><span class="n">to</span> <span class="n">the</span> <span class="n">current</span> <span class="n">distribution</span> <span class="n">to</span><span class="o">/</span><span class="n">from</span> <span class="n">the</span>
<span class="n">C</span> <span class="n">previous</span> <span class="n">ones</span><span class="p">.</span>
<span class="n">C</span>
<span class="n">C</span> <span class="o">==================================================================</span>
      <span class="k">implicit none</span>
<span class="n">C</span>     <span class="n">Passed</span> <span class="n">arguments</span>
      <span class="kt">integer</span><span class="p">,</span> <span class="k">optional</span><span class="p">,</span>  <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">iDistr</span>
      <span class="kt">integer</span><span class="p">,</span>            <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">oDistr</span>
      <span class="kt">integer</span><span class="p">,</span>            <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">nm</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
      <span class="kt">integer</span><span class="p">,</span> <span class="k">optional</span><span class="p">,</span>  <span class="k">intent</span><span class="p">(</span><span class="n">in</span><span class="p">)</span> <span class="kd">::</span> <span class="n">wload</span><span class="p">(</span><span class="o">*</span><span class="p">)</span>
<span class="n">C</span>     <span class="n">Local</span> <span class="n">variables</span>
      <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">myName</span> <span class="o">=</span> <span class="n">moduName</span><span class="o">//</span><span class="s1">&#39;initMeshDistr &#39;</span>
      <span class="kt">character</span><span class="p">(</span><span class="nb">len</span><span class="o">=*</span><span class="p">),</span> <span class="k">parameter</span> <span class="kd">::</span> <span class="n">errMsg</span> <span class="o">=</span> <span class="n">myName</span><span class="o">//</span><span class="s1">&#39;ERROR: &#39;</span>
      <span class="kt">integer</span>                     <span class="kd">::</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">PY</span><span class="p">,</span> <span class="n">PZ</span><span class="p">,</span> <span class="n">PP</span><span class="p">,</span> <span class="n">ProcessorZ</span><span class="p">,</span>
     <span class="p">&amp;</span>                               <span class="n">blocY</span><span class="p">,</span> <span class="n">blocZ</span><span class="p">,</span> <span class="n">nremY</span><span class="p">,</span> <span class="n">nremZ</span><span class="p">,</span>
     <span class="p">&amp;</span>                               <span class="n">iniY</span><span class="p">,</span> <span class="n">iniZ</span><span class="p">,</span> <span class="n">dimY</span><span class="p">,</span> <span class="n">dimZ</span><span class="p">,</span> <span class="n">nsize</span>
      <span class="k">type</span><span class="p">(</span><span class="n">meshDisType</span><span class="p">),</span>  <span class="k">pointer</span> <span class="kd">::</span> <span class="n">distr</span>
      <span class="kt">logical</span><span class="p">,</span>               <span class="k">save</span> <span class="kd">::</span> <span class="n">firstime</span><span class="o">=</span><span class="p">.</span><span class="n">true</span><span class="p">.</span>
      <span class="kt">integer</span><span class="p">,</span> <span class="k">pointer</span>            <span class="kd">::</span> <span class="n">box</span><span class="p">(:,:,:),</span> <span class="n">mybox</span><span class="p">(:,:)</span>
<span class="c">!------------------------------------------------------------------------- BEGIN</span>
      <span class="k">call </span><span class="n">timer</span><span class="p">(</span> <span class="s1">&#39;INITMESH&#39;</span><span class="p">,</span> <span class="mi">1</span> <span class="p">)</span>

<span class="n">C</span>     <span class="n">Check</span> <span class="n">the</span> <span class="n">number</span> <span class="n">of</span> <span class="n">mesh</span> <span class="n">distribution</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">oDistr</span><span class="p">.</span><span class="n">gt</span><span class="p">.</span><span class="n">maxDistr</span><span class="p">)</span>
     <span class="p">&amp;</span>  <span class="k">call </span><span class="n">die</span><span class="p">(</span> <span class="n">errMsg</span> <span class="o">//</span> <span class="s1">&#39;oDistr.gt.maxDistr&#39;</span> <span class="p">)</span>

<span class="n">C</span>     <span class="n">Reset</span> <span class="k">data if </span><span class="n">necessay</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">firstime</span><span class="p">)</span> <span class="k">then</span>
<span class="k">        do </span><span class="n">ii</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxDistr</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">box</span><span class="p">)</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">indexp</span><span class="p">)</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">idop</span><span class="p">)</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">xdop</span><span class="p">)</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">ipa</span><span class="p">)</span>
        <span class="n">enddo</span>
        <span class="k">do </span><span class="n">ii</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="p">(</span><span class="n">maxDistr</span><span class="o">*</span><span class="p">(</span><span class="n">maxDistr</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshCommu</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">src</span><span class="p">)</span>
          <span class="k">nullify</span><span class="p">(</span><span class="n">meshCommu</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">dst</span><span class="p">)</span>
        <span class="n">enddo</span>
        <span class="k">do </span><span class="n">ii</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">maxDistr</span>
          <span class="k">do </span><span class="n">jj</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span>
            <span class="k">nullify</span><span class="p">(</span><span class="n">exteCommu</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">)%</span><span class="n">src</span><span class="p">)</span>
            <span class="k">nullify</span><span class="p">(</span><span class="n">exteCommu</span><span class="p">(</span><span class="n">ii</span><span class="p">,</span><span class="n">jj</span><span class="p">)%</span><span class="n">dst</span><span class="p">)</span>
          <span class="n">enddo</span>
        <span class="n">enddo</span>
<span class="cp">#ifdef ASYNCHRONOUS</span>
        <span class="k">nullify</span><span class="p">(</span><span class="n">tBuff1</span><span class="p">)</span>
        <span class="k">nullify</span><span class="p">(</span><span class="n">tBuff2</span><span class="p">)</span>
<span class="cp">#endif</span>
        <span class="n">firstime</span> <span class="o">=</span> <span class="p">.</span><span class="n">false</span><span class="p">.</span>
      <span class="n">endif</span>

      <span class="n">distr</span> <span class="o">=&gt;</span> <span class="n">meshDistr</span><span class="p">(</span><span class="n">oDistr</span><span class="p">)</span>
<span class="n">C</span>     <span class="k">Allocate memory </span><span class="n">for</span> <span class="n">the</span> <span class="n">current</span> <span class="n">distribution</span>
      <span class="k">nullify</span><span class="p">(</span> <span class="n">distr</span><span class="p">%</span><span class="n">box</span> <span class="p">)</span>
      <span class="k">call </span><span class="n">re_alloc</span><span class="p">(</span> <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nodes</span><span class="p">,</span>
     <span class="p">&amp;</span>               <span class="s1">&#39;distr%box&#39;</span><span class="p">,</span> <span class="n">moduName</span> <span class="p">)</span>

<span class="n">C</span>     <span class="n">The</span> <span class="n">first</span> <span class="n">distribution</span> <span class="n">should</span> <span class="n">be</span> <span class="n">the</span> <span class="n">uniform</span> <span class="n">distribution</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">oDistr</span><span class="p">.</span><span class="n">eq</span><span class="p">.</span><span class="mi">1</span><span class="p">)</span> <span class="k">then</span>
<span class="k">        </span><span class="n">ProcessorZ</span> <span class="o">=</span> <span class="n">Nodes</span><span class="o">/</span><span class="n">ProcessorY</span>
        <span class="n">blocY</span> <span class="o">=</span> <span class="p">(</span><span class="n">nm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">/</span><span class="n">ProcessorY</span><span class="p">)</span> 
        <span class="n">blocZ</span> <span class="o">=</span> <span class="p">(</span><span class="n">nm</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span><span class="o">/</span><span class="n">ProcessorZ</span><span class="p">)</span> 
        <span class="n">nremY</span> <span class="o">=</span> <span class="n">nm</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">-</span> <span class="n">blocY</span><span class="o">*</span><span class="n">ProcessorY</span>
        <span class="n">nremZ</span> <span class="o">=</span> <span class="n">nm</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span> <span class="o">-</span> <span class="n">blocZ</span><span class="o">*</span><span class="n">ProcessorZ</span>

        <span class="n">PP</span>   <span class="o">=</span> <span class="mi">1</span>
        <span class="n">iniY</span> <span class="o">=</span> <span class="mi">1</span>
        <span class="k">do </span><span class="n">PY</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ProcessorY</span>
          <span class="n">dimY</span> <span class="o">=</span> <span class="n">blocY</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">PY</span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="n">nremY</span><span class="p">)</span> <span class="n">dimY</span> <span class="o">=</span> <span class="n">dimY</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="n">iniZ</span> <span class="o">=</span> <span class="mi">1</span>
          <span class="k">do </span><span class="n">PZ</span> <span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ProcessorZ</span>
            <span class="n">dimZ</span> <span class="o">=</span> <span class="n">blocZ</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">PZ</span><span class="p">.</span><span class="n">LE</span><span class="p">.</span><span class="n">nremZ</span><span class="p">)</span> <span class="n">dimZ</span> <span class="o">=</span> <span class="n">dimZ</span> <span class="o">+</span> <span class="mi">1</span>

            <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span> <span class="o">=</span> <span class="mi">1</span>
            <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span> <span class="o">=</span> <span class="n">nm</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span> <span class="o">=</span> <span class="n">iniY</span>
            <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span> <span class="o">=</span> <span class="n">iniY</span> <span class="o">+</span> <span class="n">dimY</span> <span class="o">-</span> <span class="mi">1</span>
            <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span> <span class="o">=</span> <span class="n">iniZ</span>
            <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span> <span class="o">=</span> <span class="n">iniZ</span> <span class="o">+</span> <span class="n">dimZ</span> <span class="o">-</span> <span class="mi">1</span>

            <span class="n">iniZ</span> <span class="o">=</span> <span class="n">iniZ</span> <span class="o">+</span> <span class="n">dimZ</span>
            <span class="n">PP</span>   <span class="o">=</span> <span class="n">PP</span> <span class="o">+</span> <span class="mi">1</span>
          <span class="n">enddo</span>
          <span class="n">iniY</span> <span class="o">=</span> <span class="n">iniY</span> <span class="o">+</span> <span class="n">dimY</span>
        <span class="n">enddo</span>
      <span class="k">else</span>
<span class="n">C</span>       <span class="n">In</span> <span class="n">order</span> <span class="n">to</span> <span class="n">compute</span> <span class="n">the</span> <span class="n">other</span> <span class="k">data </span><span class="n">distributions</span><span class="p">,</span> <span class="n">we</span> <span class="n">should</span> <span class="n">split</span>
<span class="n">C</span>       <span class="n">the</span> <span class="n">vector</span> <span class="s2">&quot;wload&quot;</span> <span class="n">among</span> <span class="n">the</span> <span class="n">several</span> <span class="n">processes</span>
<span class="cp">#ifdef MPI</span>
        <span class="k">if</span> <span class="p">(.</span><span class="nb">NOT</span><span class="p">.</span> <span class="nb">present</span><span class="p">(</span><span class="n">iDistr</span><span class="p">)</span> <span class="p">.</span><span class="nb">OR</span><span class="p">.</span>
     <span class="p">&amp;</span>      <span class="p">.</span><span class="nb">NOT</span><span class="p">.</span> <span class="nb">present</span><span class="p">(</span><span class="n">wload</span><span class="p">)</span> <span class="p">)</span> <span class="k">then</span>
<span class="k">          call </span><span class="n">die</span><span class="p">(</span> <span class="n">errMsg</span> <span class="o">//</span> <span class="s1">&#39;Wrong parameters&#39;</span> <span class="p">)</span>
        <span class="n">endif</span>

        <span class="k">call </span><span class="n">splitwload</span><span class="p">(</span> <span class="n">Nodes</span><span class="p">,</span> <span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">nm</span><span class="p">,</span> <span class="n">wload</span><span class="p">,</span>
     <span class="p">&amp;</span>                   <span class="n">meshDistr</span><span class="p">(</span><span class="n">iDistr</span><span class="p">),</span> <span class="n">meshDistr</span><span class="p">(</span><span class="n">oDistr</span><span class="p">)</span> <span class="p">)</span>

        <span class="k">call </span><span class="n">reordMeshNumbering</span><span class="p">(</span> <span class="n">meshDistr</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">distr</span> <span class="p">)</span>

<span class="n">C</span>       <span class="n">Precompute</span> <span class="n">the</span> <span class="n">communications</span> <span class="n">needed</span> <span class="n">to</span> <span class="n">move</span> <span class="k">data </span><span class="n">between</span> <span class="n">the</span> <span class="n">new</span> <span class="k">data</span>
<span class="n">C</span>       <span class="n">distribution</span> <span class="nb">and </span><span class="n">the</span> <span class="n">previous</span> <span class="n">ones</span><span class="p">.</span>
        <span class="n">jj</span> <span class="o">=</span> <span class="p">((</span><span class="n">oDistr</span><span class="o">-</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="p">(</span><span class="n">oDistr</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span><span class="o">/</span><span class="mi">2</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="k">do </span><span class="n">ii</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">oDistr</span><span class="o">-</span><span class="mi">1</span>
          <span class="k">call </span><span class="n">compMeshComm</span><span class="p">(</span> <span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">),</span> <span class="n">distr</span><span class="p">,</span> <span class="n">meshCommu</span><span class="p">(</span><span class="n">jj</span><span class="p">)</span> <span class="p">)</span>
          <span class="n">jj</span> <span class="o">=</span> <span class="n">jj</span> <span class="o">+</span> <span class="mi">1</span>
        <span class="n">enddo</span>
<span class="cp">#endif</span>
      <span class="n">endif</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Node</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">then</span>
<span class="k">         write</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="s2">&quot;(a,i3)&quot;</span><span class="p">)</span><span class="s2">&quot;New grid distribution: &quot;</span><span class="p">,</span> <span class="n">oDistr</span>
         <span class="k">do </span><span class="n">PP</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nodes</span>
            <span class="k">write</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span><span class="s2">&quot;(i12,3x,3(i5,a1,i5))&quot;</span><span class="p">)</span>
     <span class="err">$</span>       <span class="n">PP</span><span class="p">,</span>
     <span class="err">$</span>       <span class="p">(</span><span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">PP</span><span class="p">),</span> <span class="s2">&quot;:&quot;</span><span class="p">,</span> <span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">jj</span><span class="p">,</span><span class="n">PP</span><span class="p">),</span> <span class="n">jj</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
         <span class="n">enddo</span> 
      <span class="n">endif</span> 

      <span class="k">call </span><span class="n">timer</span><span class="p">(</span> <span class="s1">&#39;INITMESH&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="c">!--------------------------------------------------------------------------- END</span>
      <span class="k">end subroutine </span><span class="n">initMeshDistr</span>

<span class="n">C</span> <span class="o">==================================================================</span>
<span class="n">C</span> <span class="k">Allocate memory </span><span class="n">buffers</span> <span class="n">for</span> <span class="k">asynchronous </span><span class="n">communications</span><span class="p">.</span>
<span class="n">C</span> <span class="n">It</span> <span class="n">does</span> <span class="n">nothing</span> <span class="n">for</span> <span class="n">synchronous</span> <span class="n">communications</span><span class="p">.</span>
<span class="n">C</span> <span class="o">==================================================================</span>
<span class="n">C</span> <span class="k">SUBROUTINE </span><span class="n">allocASynBuffer</span><span class="p">(</span> <span class="n">ndistr</span> <span class="p">)</span>
<span class="n">C</span>
<span class="n">C</span> <span class="n">INPUT</span><span class="p">:</span>
<span class="n">C</span> <span class="kt">integer </span><span class="n">ndistr</span>  <span class="p">:</span> <span class="n">Total</span> <span class="n">number</span> <span class="n">of</span> <span class="n">distributions</span>
<span class="n">C</span>
<span class="n">C</span> <span class="n">OUTPUT</span><span class="p">:</span>
<span class="n">C</span> <span class="n">The</span> <span class="n">output</span> <span class="n">values</span> <span class="n">are</span> <span class="n">stored</span> <span class="n">in</span> <span class="n">the</span> <span class="n">current</span> <span class="k">module</span><span class="p">:</span>
<span class="n">C</span>  <span class="kt">real</span><span class="p">(</span><span class="n">grid_p</span><span class="p">)</span> <span class="n">tBuff1</span><span class="p">(:)</span> <span class="p">:</span>  <span class="n">Buffer</span> <span class="n">for</span> <span class="n">distribution</span> <span class="mi">1</span>
<span class="n">C</span>  <span class="kt">real</span><span class="p">(</span><span class="n">grid_p</span><span class="p">)</span> <span class="n">tBuff2</span><span class="p">(:)</span> <span class="p">:</span>  <span class="n">Buffer</span> <span class="n">for</span> <span class="n">other</span> <span class="n">distributions</span>
<span class="n">C</span>
<span class="n">C</span> <span class="n">BEHAVIOR</span><span class="p">:</span>
<span class="n">C</span> 
<span class="n">C</span>
<span class="n">C</span> <span class="o">==================================================================</span>
      <span class="k">subroutine </span><span class="n">allocASynBuffer</span><span class="p">(</span> <span class="n">ndistr</span> <span class="p">)</span>
      <span class="k">use </span><span class="n">mesh</span><span class="p">,</span>    <span class="n">only</span> <span class="p">:</span> <span class="n">nsm</span>
      <span class="k">implicit none</span>
<span class="n">C</span>     <span class="n">Input</span> <span class="n">variables</span>
      <span class="kt">integer</span>                     <span class="kd">::</span> <span class="n">ndistr</span>
<span class="n">C</span>     <span class="n">Local</span> <span class="n">variables</span>
      <span class="kt">integer</span>          <span class="kd">::</span> <span class="n">ii</span><span class="p">,</span> <span class="n">jj</span><span class="p">,</span> <span class="n">imax1</span><span class="p">,</span> <span class="n">imax2</span><span class="p">,</span> <span class="n">lsize</span><span class="p">,</span> <span class="n">nsp</span><span class="p">,</span> <span class="n">Lbox</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
      <span class="kt">integer</span><span class="p">,</span> <span class="k">pointer</span> <span class="kd">::</span> <span class="n">box1</span><span class="p">(:,:),</span> <span class="n">box2</span><span class="p">(:,:),</span> <span class="n">nsize</span><span class="p">(:)</span>
      <span class="kt">logical</span>          <span class="kd">::</span> <span class="n">inters</span>
<span class="c">!------------------------------------------------------------------------- BEGIN</span>
<span class="cp">#ifdef ASYNCHRONOUS</span>
<span class="n">C</span>     <span class="k">Allocate </span><span class="n">local</span> <span class="k">memory</span>
<span class="k">      </span><span class="n">nsp</span>  <span class="o">=</span> <span class="n">nsm</span><span class="o">*</span><span class="n">nsm</span><span class="o">*</span><span class="n">nsm</span>
      <span class="k">call </span><span class="n">re_alloc</span><span class="p">(</span> <span class="n">nsize</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ndistr</span><span class="p">,</span> <span class="s1">&#39;nsize&#39;</span><span class="p">,</span> <span class="n">moduName</span> <span class="p">)</span>

<span class="n">C</span>     <span class="n">Check</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">local</span> <span class="n">box</span> <span class="n">for</span> <span class="n">every</span> <span class="k">data </span><span class="n">distribution</span>
      <span class="k">do </span><span class="n">ii</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">ndistr</span>
        <span class="n">box1</span> <span class="o">=&gt;</span> <span class="n">meshDistr</span><span class="p">(</span><span class="n">ii</span><span class="p">)%</span><span class="n">box</span><span class="p">(:,:,</span><span class="n">node</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">nsize</span><span class="p">(</span><span class="n">ii</span><span class="p">)</span> <span class="o">=</span> <span class="p">(</span><span class="n">box1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">-</span><span class="n">box1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span>
     <span class="p">&amp;</span>              <span class="p">(</span><span class="n">box1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">-</span><span class="n">box1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span>
     <span class="p">&amp;</span>              <span class="p">(</span><span class="n">box1</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">-</span><span class="n">box1</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="n">nsp</span>
      <span class="n">enddo</span>

<span class="n">C</span>     <span class="n">Check</span> <span class="n">the</span> <span class="n">size</span> <span class="n">of</span> <span class="n">the</span> <span class="n">intersections</span> <span class="n">between</span> <span class="n">the</span> <span class="n">first</span> <span class="k">data </span><span class="n">distributions</span>
<span class="n">C</span>     <span class="nb">and </span><span class="n">the</span> <span class="n">others</span> <span class="k">data </span><span class="n">distributions</span><span class="p">.</span>
<span class="n">C</span>     <span class="n">Buffers</span> <span class="n">don</span><span class="s1">&#39;t need to store intersections</span>
<span class="s1">      imax1 = 0</span>
<span class="s1">      imax2 = 0</span>
<span class="s1">      box1 =&gt; meshDistr(1)%box(:,:,node+1)</span>
<span class="s1">      do ii= 2, ndistr</span>
<span class="s1">        box2 =&gt; meshDistr(ii)%box(:,:,node+1)</span>
<span class="s1">        call boxIntersection( box1, box2, Lbox, inters )</span>
<span class="s1">        if (inters) then</span>
<span class="s1">          lsize = (Lbox(2,1)-Lbox(1,1)+1)*</span>
<span class="s1">     &amp;            (Lbox(2,2)-Lbox(1,2)+1)*</span>
<span class="s1">     &amp;            (Lbox(2,3)-Lbox(1,3)+1)*nsp</span>
<span class="s1">        else</span>
<span class="s1">          lsize = 0</span>
<span class="s1">        endif</span>
<span class="s1">        imax1 = max(imax1,nsize(1)-lsize)</span>
<span class="s1">        imax2 = max(imax2,nsize(ii)-lsize)</span>
<span class="s1">      enddo</span>

<span class="s1">C     Deallocate local memory</span>
<span class="s1">      call de_alloc( nsize, &#39;</span><span class="n">nsize</span><span class="s1">&#39;, moduName )</span>

<span class="s1">C     Allocate memory for asynchronous communications</span>
<span class="s1">      call re_alloc( tBuff1, 1, imax1, &#39;</span><span class="n">tBuff1</span><span class="s1">&#39;, moduName )</span>
<span class="s1">      call re_alloc( tBuff2, 1, imax2, &#39;</span><span class="n">tBuff2</span><span class="s1">&#39;, moduName )</span>
<span class="s1">#endif</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine allocASynBuffer</span>


<span class="s1">      subroutine allocExtMeshDistr( iDistr, nep, mop )</span>
<span class="s1">      use mesh, only: indexp, idop, xdop</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Input variables</span>
<span class="s1">      integer,         intent(in) :: iDistr, nep, mop</span>
<span class="s1">C     Local variables</span>
<span class="s1">      type(meshDisType),  pointer :: distr</span>

<span class="s1">      distr =&gt; meshDistr(iDistr)</span>
<span class="s1">      call re_alloc( distr%indexp, 1, nep, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">indexp</span><span class="s1">&#39;, moduName )</span>
<span class="s1">      call re_alloc( distr%idop, 1, mop, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">idop</span><span class="s1">&#39;, moduName )</span>
<span class="s1">      call re_alloc( distr%xdop, 1, 3, 1, mop, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">xdop</span><span class="s1">&#39;, moduName )</span>

<span class="s1">      indexp =&gt; distr%indexp</span>
<span class="s1">      idop   =&gt; distr%idop</span>
<span class="s1">      xdop   =&gt; distr%xdop</span>
<span class="s1">      end subroutine allocExtMeshDistr</span>

<span class="s1">      subroutine allocIpaDistr( iDistr, na )</span>
<span class="s1">      use mesh, only: ipa</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Input variables</span>
<span class="s1">      integer,         intent(in) :: iDistr, na</span>
<span class="s1">C     Local variables</span>
<span class="s1">      type(meshDisType),  pointer :: distr</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      distr =&gt; meshDistr(iDistr)</span>
<span class="s1">      call re_alloc( distr%ipa, 1, na, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">ipa</span><span class="s1">&#39;, moduName )</span>
<span class="s1">      ipa =&gt; meshDistr(iDistr)%ipa</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine allocIpaDistr</span>

<span class="s1">      subroutine setMeshDistr( iDistr, nsm, nsp, nml, nmpl, ntml, ntpl )</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C Fixes the new data limits and dimensions of the mesh to those of</span>
<span class="s1">C the data distribution iDistr.</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE setMeshDistr( iDistr, nsm, nsp, nml, nmpl, ntml, ntpl )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer iDistr  : Distribution index of the input vector</span>
<span class="s1">C integer nsm     : Number of mesh sub-divisions in each direction</span>
<span class="s1">C integer nsp     : Number of sub-points of each mesh point</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C integer nml(3)  : Local number of Mesh divisions in each cell vector</span>
<span class="s1">C integer nmpl    : Local number of Mesh divisions</span>
<span class="s1">C integer ntml(3) : Local number of Mesh points in each cell vector</span>
<span class="s1">C integer ntpl    : Local number of Mesh points</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C Fixes the new data limits and dimensions of the mesh to those of</span>
<span class="s1">C the data distribution iDistr.</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      use mesh, only: meshLim, indexp, ipa, idop, xdop</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,  intent(in) :: iDistr, nsm, nsp</span>
<span class="s1">      integer, intent(out) :: nml(3), nmpl, ntml(3), ntpl</span>
<span class="s1">C     Local variables</span>
<span class="s1">      type(meshDisType),  pointer :: distr</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      distr =&gt; meshDistr(iDistr)</span>

<span class="s1">      meshLim = distr%box(1:2,1:3,node+1)</span>
<span class="s1">      nml(1) = (MeshLim(2,1)-MeshLim(1,1)) + 1</span>
<span class="s1">      nml(2) = (MeshLim(2,2)-MeshLim(1,2)) + 1</span>
<span class="s1">      nml(3) = (MeshLim(2,3)-MeshLim(1,3)) + 1</span>
<span class="s1">      nmpl   = nml(1)*nml(2)*nml(3)</span>
<span class="s1">      ntml   = nml*nsm</span>
<span class="s1">      ntpl   = nmpl*nsp</span>

<span class="s1">      indexp =&gt; distr%indexp</span>
<span class="s1">      idop   =&gt; distr%idop</span>
<span class="s1">      xdop   =&gt; distr%xdop</span>
<span class="s1">      ipa    =&gt; distr%ipa</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine setMeshDistr</span>

<span class="s1">      subroutine resetMeshDistr( iDistr )</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C Reset the data of the distribution iDistr</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE resetMeshDistr( iDistr )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer iDistr   : Distribution index to be reset.</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C Modify data of the current module.</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C Deallocate associated arrays of the current distribution</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer, optional,  intent(in) :: iDistr</span>
<span class="s1">C     Local variables</span>
<span class="s1">      integer                        :: idis, ini, fin, icom</span>
<span class="s1">      type(meshDisType),  pointer    :: distr</span>
<span class="s1">      type(meshCommType), pointer    :: mcomm</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      if (present(iDistr)) then</span>
<span class="s1">        ini = iDistr</span>
<span class="s1">        fin = iDistr</span>
<span class="s1">      else</span>
<span class="s1">        ini = 1</span>
<span class="s1">        fin = maxDistr</span>
<span class="s1">      endif</span>

<span class="s1">      do idis= ini, fin</span>
<span class="s1">        distr =&gt; meshDistr(idis)</span>

<span class="s1">        distr%nMesh = 0</span>

<span class="s1">        if (associated(distr%box)) then</span>
<span class="s1">          call de_alloc( distr%box, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">box</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        if (associated(distr%indexp)) then</span>
<span class="s1">          call de_alloc( distr%indexp, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">indexp</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                   &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        if (associated(distr%idop)) then</span>
<span class="s1">          call de_alloc( distr%idop, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">idop</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                   &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        if (associated(distr%xdop)) then</span>
<span class="s1">          call de_alloc( distr%xdop, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">xdop</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                   &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        if (associated(distr%ipa)) then</span>
<span class="s1">          call de_alloc( distr%ipa, &#39;</span><span class="n">distr</span><span class="p">%</span><span class="n">ipa</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                   &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        do icom=1, 3</span>
<span class="s1">          mcomm =&gt; exteCommu(idis,icom)</span>
<span class="s1">          if (associated(mcomm%src)) then</span>
<span class="s1">            call de_alloc( mcomm%src, &#39;</span><span class="n">mcomm</span><span class="p">%</span><span class="n">src</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">          endif</span>
<span class="s1">          if (associated(mcomm%dst)) then</span>
<span class="s1">            call de_alloc( mcomm%dst, &#39;</span><span class="n">mcomm</span><span class="p">%</span><span class="n">dst</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">          endif</span>
<span class="s1">          mcomm%ncom = 0</span>
<span class="s1">        enddo</span>

<span class="s1">        do icom= ((idis-2)*(idis-1))/2 + 1, ((idis-1)*idis)/2</span>
<span class="s1">          mcomm =&gt; meshCommu(icom)</span>
<span class="s1">          if (associated(mcomm%src)) then</span>
<span class="s1">            call de_alloc( mcomm%src, &#39;</span><span class="n">mcomm</span><span class="p">%</span><span class="n">src</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">          endif</span>
<span class="s1">          if (associated(mcomm%dst)) then</span>
<span class="s1">            call de_alloc( mcomm%dst, &#39;</span><span class="n">mcomm</span><span class="p">%</span><span class="n">dst</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">          endif</span>
<span class="s1">          mcomm%ncom = 0</span>
<span class="s1">        enddo</span>
<span class="s1">      enddo</span>

<span class="s1">#ifdef ASYNCHRONOUS</span>
<span class="s1">      if (associated(tBuff1)) then</span>
<span class="s1">        call de_alloc(tBuff1, &#39;</span><span class="n">tBuff1</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      endif</span>
<span class="s1">      if (associated(tBuff2)) then</span>
<span class="s1">        call de_alloc(tBuff2, &#39;</span><span class="n">tBuff2</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      endif</span>
<span class="s1">#endif</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine resetMeshDistr</span>

<span class="s1">C ==================================================================</span>
<span class="s1">C Move data from vector fsrc, that uses distribution iDistr, to vector</span>
<span class="s1">C fdst, that uses distribution oDistr. It also, re-orders a clustered</span>
<span class="s1">C data array into a sequential one and viceversa.</span>
<span class="s1">C If this is a sequencial execution, it only reorders the data.</span>
<span class="s1">C</span>
<span class="s1">C NOTE: There are two subroutines: one to deal with real data and</span>
<span class="s1">C the other with integers. Both are called using the same interface.</span>
<span class="s1">!</span>
<span class="s1">! AG: NOTE that the integer version does NOT have the exact functionality</span>
<span class="s1">! of the real version. In particular, the integer version has no provision</span>
<span class="s1">! for a &quot;serial fallback&quot;, and so this case has been trapped.</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE distMeshData( iDistr, fsrc, oDistr, fdst, itr )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer      iDistr : Distribution index of the input vector.</span>
<span class="s1">C real/integer fsrc   : Input vector.</span>
<span class="s1">C integer      oDistr : Distribution index of the output vector.</span>
<span class="s1">C integer itr         : TRanslation-direction switch</span>
<span class="s1">C                       ITR=+1 =&gt; From clustered to sequential</span>
<span class="s1">C                       ITR=-1 =&gt; From sequential to clustered</span>
<span class="s1">C                       ITR=0  =&gt; Keep the status</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C real/integer fdst   : Output vector.</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C Check the communications that this process should do to move data</span>
<span class="s1">C from iDistr to odistr. We have 3 kind of communications (send, receive</span>
<span class="s1">C and keep on the same node). We have 3 kind of reorderings (clustered to</span>
<span class="s1">C sequential, sequential to clustered and keep the same ordering).</span>
<span class="s1">C</span>
<span class="s1">C For the sequencial code we call subroutine reord</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">#ifdef ASYNCHRONOUS</span>
<span class="s1">      subroutine distMeshData_rea( iDistr, fsrc, oDistr, fdst, itr )</span>
<span class="s1">      use mesh,    only : nsm, nmeshg</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">      use mpi_siesta</span>
<span class="s1">#endif</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,         intent(in) :: iDistr, oDistr, itr</span>
<span class="s1">      real(grid_p),    intent(in) :: fsrc(*)</span>
<span class="s1">      real(grid_p),   intent(out) :: fdst(*)</span>
<span class="s1">C     Local variables</span>
<span class="s1">      integer                     :: i, I1, I2, I3, N1, N2, N3, NN, ind,</span>
<span class="s1">     &amp;                               J1, J2, J3, K1, K2, K3, KS, KR,</span>
<span class="s1">     &amp;                               icom, ncom, nsp, me, nsize, lsize,</span>
<span class="s1">     &amp;                               NSRC(3), NDST(3), Lbox(2,3), ierr,</span>
<span class="s1">     &amp;                               nm(3), status(MPI_Status_Size),</span>
<span class="s1">     &amp;                               Xsize, Ysize, Zsize</span>
<span class="s1">      logical                     :: inters</span>
<span class="s1">      integer,            pointer :: request(:), src(:), dst(:),</span>
<span class="s1">     &amp;                               Sbox(:,:), Dbox(:,:), JS(:)</span>
<span class="s1">      real(grid_p),       pointer :: sBuff(:), rBuff(:)</span>
<span class="s1">      type(meshDisType),  pointer :: idis, odis</span>

<span class="s1">#ifdef DEBUG</span>
<span class="s1">      call write_debug( &#39;</span>    <span class="n">PRE</span> <span class="n">distMeshData</span><span class="s1">&#39; )</span>
<span class="s1">#endif</span>
<span class="s1">#ifdef _TRACE_</span>
<span class="s1">      call MPI_Barrier( MPI_Comm_World, ierr )</span>
<span class="s1">      call MPItrace_event( 1000, 6 )</span>
<span class="s1">#endif</span>
<span class="s1">      call timer( &#39;</span><span class="n">COMM_BSC</span><span class="s1">&#39;, 1 )</span>

<span class="s1">      nm(1:3) = nmeshg(1:3) / nsm</span>
<span class="s1">      if (nodes == 1) then</span>

<span class="s1">        if (itr.gt.0) then</span>
<span class="s1">          ! Note that in reord the first argument is always</span>
<span class="s1">          ! clustered</span>
<span class="s1">          call reord( fsrc, fdst, nm, nsm, TO_SEQUENTIAL )</span>
<span class="s1">        else if (itr .lt. 0) then</span>
<span class="s1">          call reord( fdst, fsrc, nm, nsm, TO_CLUSTER )</span>
<span class="s1">        else</span>
<span class="s1">          ! Copy source to destination </span>
<span class="s1">          ! This will be executed only in serial mode,</span>
<span class="s1">          ! so we know that the size is the total number</span>
<span class="s1">          ! of (small) points, but maybe this information</span>
<span class="s1">          ! should be more explicit.</span>
<span class="s1">          nsize = product(nmeshg(1:3))</span>
<span class="s1">          fdst(1:nsize) = fsrc(1:nsize)</span>
<span class="s1">        endif</span>
<span class="s1">      else  ! nodes &gt; 1</span>
<span class="s1">C       The communications are stored in a triangular structure.</span>
<span class="s1">        if (iDistr.gt.oDistr) then</span>
<span class="s1">          ind  = ((iDistr-1)*(iDistr-2))/2 + oDistr</span>
<span class="s1">          ncom = meshCommu(ind)%ncom</span>
<span class="s1">          src =&gt; meshCommu(ind)%dst</span>
<span class="s1">          dst =&gt; meshCommu(ind)%src</span>
<span class="s1">        else</span>
<span class="s1">          ind = ((oDistr-1)*(oDistr-2))/2 + iDistr</span>
<span class="s1">          ncom = meshCommu(ind)%ncom</span>
<span class="s1">          src =&gt; meshCommu(ind)%src</span>
<span class="s1">          dst =&gt; meshCommu(ind)%dst</span>
<span class="s1">        endif</span>

<span class="s1">        nullify( request )</span>
<span class="s1">        call re_alloc( request, 1, ncom, &#39;</span><span class="n">request</span><span class="s1">&#39;, &#39;</span><span class="n">distmeshdata</span><span class="s1">&#39; )</span>

<span class="s1">        idis =&gt; meshDistr(iDistr)</span>
<span class="s1">        odis =&gt; meshDistr(oDistr)</span>

<span class="s1">        nsp = nsm*nsm*nsm</span>
<span class="s1">        me  = node + 1</span>
<span class="s1">        nullify( JS )</span>
<span class="s1">        call re_alloc( JS, 1, nsp, &#39;</span><span class="n">JS</span><span class="s1">&#39;, &#39;</span><span class="n">distmeshdata</span><span class="s1">&#39; )</span>

<span class="s1">        if (iDistr.eq.UNIFORM) then</span>
<span class="s1">          sBuff =&gt; tBuff1(:)</span>
<span class="s1">          rBuff =&gt; tBuff2(:)</span>
<span class="s1">        else</span>
<span class="s1">          if (oDistr.eq.UNIFORM) then</span>
<span class="s1">            sBuff =&gt; tBuff2(:)</span>
<span class="s1">            rBuff =&gt; tBuff1(:)</span>
<span class="s1">          else</span>
<span class="s1">!           Asynchronous buffers are sized to move data from/to</span>
<span class="s1">!           UNIFORM distribution. Check subroutine allocASynBuffer</span>
<span class="s1">!           to contemplate different cases</span>
<span class="s1">            call die( &#39;</span><span class="k">Asynchronous </span><span class="n">temporal</span> <span class="n">buffer</span> <span class="n">error</span><span class="s1">&#39; )</span>
<span class="s1">          endif</span>
<span class="s1">        endif</span>

<span class="s1">        Sbox =&gt; idis%box(:,:,ME)</span>
<span class="s1">        NSRC(1) = (Sbox(2,1) - Sbox(1,1) + 1)*nsm</span>
<span class="s1">        NSRC(2) = (Sbox(2,2) - Sbox(1,2) + 1)*nsm</span>
<span class="s1">        NSRC(3) = (Sbox(2,3) - Sbox(1,3) + 1)*nsm</span>

<span class="s1">        Dbox =&gt; odis%box(:,:,ME)</span>
<span class="s1">        NDST(1) = (Dbox(2,1) - Dbox(1,1) + 1)*nsm</span>
<span class="s1">        NDST(2) = (Dbox(2,2) - Dbox(1,2) + 1)*nsm</span>
<span class="s1">        NDST(3) = (Dbox(2,3) - Dbox(1,3) + 1)*nsm</span>

<span class="s1">        if (itr.eq.1) then</span>
<span class="s1">C         From clustered to sequential</span>
<span class="s1">          NN = 1</span>
<span class="s1">          I3 = 0</span>
<span class="s1">          DO N3=0, NSM-1</span>
<span class="s1">            I2 = 0</span>
<span class="s1">            DO N2= 0, NSM-1</span>
<span class="s1">              I1 = I2 + I3</span>
<span class="s1">              DO N1= 0, NSM-1</span>
<span class="s1">                JS(NN) = I1</span>
<span class="s1">                NN     = NN + 1</span>
<span class="s1">                I1     = I1 + 1</span>
<span class="s1">              ENDDO</span>
<span class="s1">              I2 = I2 + NDST(1)</span>
<span class="s1">            ENDDO</span>
<span class="s1">            I3 = I3 + NDST(1)*NDST(2)</span>
<span class="s1">          ENDDO</span>

<span class="s1">          KS = 1</span>
<span class="s1">          KR = 1</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>

<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM*NSM</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSP + 1 + J2 + J3</span>
<span class="s1">                    K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        fdst(K1+JS(NN)) = fsrc(J1)</span>
<span class="s1">                        J1 = J1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                      K1 = K1 + NSM</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM*NSM</span>
<span class="s1">                    K2 = K2 + NDST(1)*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                lsize = (Lbox(2,1) - Lbox(1,1) + 1)*</span>
<span class="s1">     &amp;                  (Lbox(2,2) - Lbox(1,2) + 1)*</span>
<span class="s1">     &amp;                  (Lbox(2,3) - Lbox(1,3) + 1)*nsp</span>

<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K1 = KS</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSP + 1 + J2 + J3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        sBuff(K1) = fsrc(J1)</span>
<span class="s1">                        J1 = J1 + 1</span>
<span class="s1">                        K1 = K1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call mpi_isend( sBuff(KS), lsize, MPI_grid_real,</span>
<span class="s1">     &amp;                          dst(icom)-1, 0, MPI_COMM_WORLD,</span>
<span class="s1">     &amp;                          request(icom), ierr )</span>
<span class="s1">#endif</span>
<span class="s1">                KS = K1</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">              lsize = (Lbox(2,1) - Lbox(1,1) + 1)*</span>
<span class="s1">     &amp;                (Lbox(2,2) - Lbox(1,2) + 1)*</span>
<span class="s1">     &amp;                (Lbox(2,3) - Lbox(1,3) + 1)*nsp</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_irecv( rBuff(KR), lsize, MPI_grid_real,</span>
<span class="s1">     &amp;                        src(icom)-1, 0, MPI_COMM_WORLD,</span>
<span class="s1">     &amp;                        request(icom), ierr )</span>
<span class="s1">#endif</span>
<span class="s1">              KR = KR + lsize</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>

<span class="s1">          J1 = 1</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">C           Wait for received data and move it to the destination buffer</span>
<span class="s1">            if (src(icom).ne.ME) then</span>
<span class="s1">              Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">              Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">              call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              CALL MPI_WAIT( request(icom), status, ierr )</span>
<span class="s1">#endif</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">              do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                  K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                  do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                    DO NN= 1, NSP</span>
<span class="s1">                      fdst(K1+JS(NN)) = rBuff(J1)</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    ENDDO</span>
<span class="s1">                    K1 = K1 + NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else if (itr.eq.-1) then</span>
<span class="s1">C         From sequencial to clustered</span>
<span class="s1">          NN = 1</span>
<span class="s1">          I3 = 0</span>
<span class="s1">          DO N3=0, NSM-1</span>
<span class="s1">            I2 = 0</span>
<span class="s1">            DO N2= 0, NSM-1</span>
<span class="s1">              I1 = I2 + I3</span>
<span class="s1">              DO N1= 0, NSM-1</span>
<span class="s1">                JS(NN) = I1</span>
<span class="s1">                NN     = NN + 1</span>
<span class="s1">                I1     = I1 + 1</span>
<span class="s1">              ENDDO</span>
<span class="s1">              I2 = I2 + NSRC(1)</span>
<span class="s1">            ENDDO</span>
<span class="s1">            I3 = I3 + NSRC(1)*NSRC(2)</span>
<span class="s1">          ENDDO</span>

<span class="s1">          KS = 1</span>
<span class="s1">          KR = 1</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>

<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    K1 = (Lbox(1,1) - Dbox(1,1))*NSP + 1 + K2 + K3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        fdst(K1) = fsrc(J1+JS(NN))</span>
<span class="s1">                        K1 = K1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                      J1 = J1 + NSM</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM</span>
<span class="s1">                    K2 = K2 + NDST(1)*NSM*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                lsize = (Lbox(2,1) - Lbox(1,1) + 1)*</span>
<span class="s1">     &amp;                  (Lbox(2,2) - Lbox(1,2) + 1)*</span>
<span class="s1">     &amp;                  (Lbox(2,3) - Lbox(1,3) + 1)*nsp</span>

<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K1 = KS</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        sBuff(K1) = fsrc(J1+JS(NN))</span>
<span class="s1">                        K1 = K1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                      J1 = J1 + NSM</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call mpi_isend( sBuff(KS), lsize, MPI_grid_real,</span>
<span class="s1">     &amp;                          dst(icom)-1, 0, MPI_COMM_WORLD,</span>
<span class="s1">     &amp;                          request(icom), ierr )</span>
<span class="s1">#endif</span>
<span class="s1">                KS = K1</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">              lsize = (Lbox(2,1) - Lbox(1,1) + 1)*</span>
<span class="s1">     &amp;                (Lbox(2,2) - Lbox(1,2) + 1)*</span>
<span class="s1">     &amp;                (Lbox(2,3) - Lbox(1,3) + 1)*nsp</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_irecv( rBuff(KR), lsize, MPI_grid_real,</span>
<span class="s1">     &amp;                        src(icom)-1, 0, MPI_COMM_WORLD,</span>
<span class="s1">     &amp;                        request(icom), ierr )</span>
<span class="s1">#endif</span>
<span class="s1">              KR = KR + lsize</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>

<span class="s1">          J1 = 1</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">C           Wait for received data and move it to the destination buffer</span>
<span class="s1">            if (src(icom).ne.ME) then</span>
<span class="s1">              Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">              Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">              call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              CALL MPI_WAIT( request(icom), status, ierr )</span>
<span class="s1">#endif</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">              do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM*NSM</span>
<span class="s1">                do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                  K1 = (Lbox(1,1) - Dbox(1,1))*NSP + 1 + K2 + K3</span>
<span class="s1">                  do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                    DO NN= 1, NSP</span>
<span class="s1">                      fdst(K1) = rBuff(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    ENDDO</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)*NSM*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else if (itr.eq.0) then</span>
<span class="s1">          KS = 1</span>
<span class="s1">          KR = 1</span>
<span class="s1">C         From sequencial to sequencial or from clustered to clustered</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            Xsize = (Lbox(2,1)-Lbox(1,1)+1)*NSM</span>
<span class="s1">            Ysize = (Lbox(2,2)-Lbox(1,2)+1)*NSM</span>
<span class="s1">            Zsize = (Lbox(2,3)-Lbox(1,3)+1)*NSM</span>

<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">                do I3 = 1, Zsize</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                  do I2 = 1, Ysize</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                    do I1 = 1, Xsize</span>
<span class="s1">                      fdst(K1) = fsrc(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)</span>
<span class="s1">                    K2 = K2 + NDST(1)</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                lsize = Xsize*Ysize*Zsize</span>

<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K1 = KS</span>
<span class="s1">                do I3 = 1, Zsize</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  do I2 = 1, Ysize</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    do I1 = 1, Xsize</span>
<span class="s1">                      sBuff(K1) = fsrc(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)</span>
<span class="s1">                enddo</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call mpi_isend( sBuff(KS), lsize, MPI_grid_real,</span>
<span class="s1">     &amp;                          dst(icom)-1, 0, MPI_COMM_WORLD,</span>
<span class="s1">     &amp;                          request(icom), ierr )</span>
<span class="s1">#endif</span>
<span class="s1">                KS = K1</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">              lsize = Xsize*Ysize*Zsize</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_irecv( rBuff(KR), lsize, MPI_grid_real,</span>
<span class="s1">     &amp;                        src(icom)-1, 0, MPI_COMM_WORLD,</span>
<span class="s1">     &amp;                        request(icom), ierr )</span>
<span class="s1">#endif</span>
<span class="s1">              KR = KR + lsize</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>

<span class="s1">          J1 = 1</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">C           Wait for received data and move it to the destination buffer</span>
<span class="s1">            if (src(icom).ne.ME) then</span>
<span class="s1">              Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">              Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">              call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">              Xsize = (Lbox(2,1)-Lbox(1,1)+1)*NSM</span>
<span class="s1">              Ysize = (Lbox(2,2)-Lbox(1,2)+1)*NSM</span>
<span class="s1">              Zsize = (Lbox(2,3)-Lbox(1,3)+1)*NSM</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              CALL MPI_WAIT( request(icom), status, ierr )</span>
<span class="s1">#endif</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">              do I3 = 1, Zsize</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                do I2 = 1, Ysize</span>
<span class="s1">                  K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                  do I1 = 1, Xsize</span>
<span class="s1">                    fdst(K1) = rBuff(J1)</span>
<span class="s1">                    K1 = K1 + 1</span>
<span class="s1">                    J1 = J1 + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else</span>
<span class="s1">          if (Node.eq.0) then</span>
<span class="s1">            write(*,*)&#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">Wrong</span> <span class="k">parameter </span><span class="n">for</span> <span class="k">function </span><span class="n">distMeshData</span><span class="s1">&#39;</span>
<span class="s1">          endif</span>
<span class="s1">          call die()</span>
<span class="s1">        endif</span>

<span class="s1">        call de_alloc( JS,      &#39;</span><span class="n">JS</span><span class="s1">&#39;,      &#39;</span><span class="n">distmeshdata</span><span class="s1">&#39; )</span>
<span class="s1">        call de_alloc( request, &#39;</span><span class="n">request</span><span class="s1">&#39;, &#39;</span><span class="n">distmeshdata</span><span class="s1">&#39; )</span>
<span class="s1">      endif</span>

<span class="s1">#ifdef _TRACE_</span>
<span class="s1">      call MPI_Barrier( MPI_Comm_World, ierr )</span>
<span class="s1">      call MPItrace_event( 1000, 0 )</span>
<span class="s1">#endif</span>
<span class="s1">      call timer( &#39;</span><span class="n">COMM_BSC</span><span class="s1">&#39;, 2 )</span>
<span class="s1">#ifdef DEBUG</span>
<span class="s1">      call write_debug( &#39;</span>    <span class="n">POS</span> <span class="n">distMeshData</span><span class="s1">&#39; )</span>
<span class="s1">#endif</span>
<span class="s1">      end subroutine distMeshData_rea</span>
<span class="s1">#else /* SYNCHRONOUS communications */</span>
<span class="s1">      subroutine distMeshData_rea( iDistr, fsrc, oDistr, fdst, itr )</span>
<span class="s1">      use mesh,    only : nsm, nmeshg</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">      use mpi_siesta</span>
<span class="s1">#endif</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,       intent(in) :: iDistr, oDistr, itr</span>
<span class="s1">      real(grid_p),  intent(in) :: fsrc(*)</span>
<span class="s1">      real(grid_p), intent(out) :: fdst(*)</span>

<span class="s1">C     Local variables</span>
<span class="s1">      character(len=*), parameter :: myName = moduName//&#39;</span><span class="n">distMeshData</span> <span class="s1">&#39;</span>
<span class="s1">      character(len=*), parameter :: errMsg = myName//&#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="s1">&#39;</span>
<span class="s1">      integer                     :: I1, I2, I3, J1, J2, J3, K1, K2, K3,</span>
<span class="s1">     &amp;                               N1, N2, N3, NN, ind, ncom,</span>
<span class="s1">     &amp;                               icom, NSP, NSRC(3), NDST(3), ME,</span>
<span class="s1">     &amp;                               MaxSize, Xsize, Ysize, Zsize,</span>
<span class="s1">     &amp;                               Lbox(2,3)</span>
<span class="s1">      integer, pointer            :: src(:), dst(:), JS(:), Sbox(:,:),</span>
<span class="s1">     &amp;                               Dbox(:,:)</span>
<span class="s1">      type(meshDisType),  pointer :: idis, odis</span>
<span class="s1">      logical                     :: inters</span>
<span class="s1">      real(grid_p),       pointer :: TBUF(:)</span>
<span class="s1">      integer                     :: nsize, nm(3)</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">      integer                     :: MPIerror, Status(MPI_Status_Size)</span>
<span class="s1">#endif</span>
<span class="s1">!----------------------------------------------------------------------- BEGIN</span>
<span class="s1">#ifdef DEBUG</span>
<span class="s1">      call write_debug( &#39;</span>    <span class="n">PRE</span> <span class="n">distMeshData</span><span class="s1">&#39; )</span>
<span class="s1">#endif</span>
<span class="s1">#ifdef _TRACE_</span>
<span class="s1">      call MPI_Barrier( MPI_Comm_World, MPIerror )</span>
<span class="s1">      call MPItrace_event( 1000, 6 )</span>
<span class="s1">#endif</span>
<span class="s1">      call timer( &#39;</span><span class="n">COMM_BSC</span><span class="s1">&#39;, 1 )</span>

<span class="s1">      if (nodes == 1) then</span>
<span class="s1">        nm(1:3) = nmeshg(1:3)/nsm</span>
<span class="s1">        if (itr.gt.0) then</span>
<span class="s1">           ! Note that in reord the first argument is always</span>
<span class="s1">           ! clustered</span>
<span class="s1">           call reord( fsrc, fdst, nm, nsm, TO_SEQUENTIAL )</span>
<span class="s1">        else if (itr .lt. 0) then</span>
<span class="s1">           call reord( fdst, fsrc, nm, nsm, TO_CLUSTER )</span>
<span class="s1">        else</span>
<span class="s1">           ! Copy source to destination </span>
<span class="s1">           ! This will be executed only in serial mode,</span>
<span class="s1">           ! so we know that the size is the total number</span>
<span class="s1">           ! of (small) points, but maybe this information</span>
<span class="s1">           ! should be more explicit.</span>
<span class="s1">           nsize = product(nmeshg(1:3))</span>
<span class="s1">           fdst(1:nsize) = fsrc(1:nsize)</span>
<span class="s1">        endif</span>

<span class="s1">      else  ! nodes &gt; 1</span>
<span class="s1">C       The communications are stored in a triangular structure.</span>
<span class="s1">        if (iDistr.gt.oDistr) then</span>
<span class="s1">          ind  = ((iDistr-1)*(iDistr-2))/2 + oDistr</span>
<span class="s1">          ncom = meshCommu(ind)%ncom</span>
<span class="s1">          src =&gt; meshCommu(ind)%dst</span>
<span class="s1">          dst =&gt; meshCommu(ind)%src</span>
<span class="s1">        else</span>
<span class="s1">          ind = ((oDistr-1)*(oDistr-2))/2 + iDistr</span>
<span class="s1">          ncom = meshCommu(ind)%ncom</span>
<span class="s1">          src =&gt; meshCommu(ind)%src</span>
<span class="s1">          dst =&gt; meshCommu(ind)%dst</span>
<span class="s1">        endif</span>

<span class="s1">        idis =&gt; meshDistr(iDistr)</span>
<span class="s1">        odis =&gt; meshDistr(oDistr)</span>

<span class="s1">        NSP = NSM*NSM*NSM</span>
<span class="s1">        ME  = Node + 1</span>

<span class="s1">        nullify( JS )</span>
<span class="s1">        call re_alloc( JS, 1, NSP, &#39;</span><span class="n">JS</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>

<span class="s1">C       Compute the maximum size of the buffer needed to transfer data</span>
<span class="s1">C       among the several processes</span>
<span class="s1">        maxSize = 0</span>
<span class="s1">        do icom= 1, ncom</span>
<span class="s1">          if (src(icom).ne.dst(icom)) then</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">            Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">            Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">            MaxSize = max(MaxSize,Xsize*Ysize*Zsize)</span>
<span class="s1">          endif</span>
<span class="s1">        enddo</span>

<span class="s1">        MaxSize = MaxSize*nsp</span>
<span class="s1">        if (MaxSize.gt.0) then</span>
<span class="s1">          nullify( TBUF )</span>
<span class="s1">          call re_alloc( TBUF, 1, MaxSize, &#39;</span><span class="n">TBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        Sbox =&gt; idis%box(:,:,ME)</span>
<span class="s1">        NSRC(1) = (Sbox(2,1) - Sbox(1,1) + 1)*nsm</span>
<span class="s1">        NSRC(2) = (Sbox(2,2) - Sbox(1,2) + 1)*nsm</span>
<span class="s1">        NSRC(3) = (Sbox(2,3) - Sbox(1,3) + 1)*nsm</span>
<span class="s1">        Dbox =&gt; odis%box(:,:,ME)</span>
<span class="s1">        NDST(1) = (Dbox(2,1) - Dbox(1,1) + 1)*nsm</span>
<span class="s1">        NDST(2) = (Dbox(2,2) - Dbox(1,2) + 1)*nsm</span>
<span class="s1">        NDST(3) = (Dbox(2,3) - Dbox(1,3) + 1)*nsm</span>

<span class="s1">        if (itr.eq.1) then</span>
<span class="s1">C         From clustered to sequential</span>
<span class="s1">          NN = 1</span>
<span class="s1">          I3 = 0</span>
<span class="s1">          DO N3=0, NSM-1</span>
<span class="s1">            I2 = 0</span>
<span class="s1">            DO N2= 0, NSM-1</span>
<span class="s1">              I1 = I2 + I3</span>
<span class="s1">              DO N1= 0, NSM-1</span>
<span class="s1">                JS(NN) = I1</span>
<span class="s1">                NN     = NN + 1</span>
<span class="s1">                I1     = I1 + 1</span>
<span class="s1">              ENDDO</span>
<span class="s1">              I2 = I2 + NDST(1)</span>
<span class="s1">            ENDDO</span>
<span class="s1">            I3 = I3 + NDST(1)*NDST(2)</span>
<span class="s1">          ENDDO</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM*NSM</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSP + 1 + J2 + J3</span>
<span class="s1">                    K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        fdst(K1+JS(NN)) = fsrc(J1)</span>
<span class="s1">                        J1 = J1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                      K1 = K1 + NSM</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM*NSM</span>
<span class="s1">                    K2 = K2 + NDST(1)*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K1 = 1</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSP + 1 + J2 + J3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        TBUF(K1) = fsrc(J1)</span>
<span class="s1">                        J1 = J1 + 1</span>
<span class="s1">                        K1 = K1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                enddo</span>

<span class="s1">                Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">                Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">                Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call MPI_Send( TBUF, Xsize*Ysize*Zsize*nsp,</span>
<span class="s1">     &amp;                         MPI_grid_real, dst(icom)-1, 1,</span>
<span class="s1">     &amp;                         MPI_Comm_world, MPIerror )</span>
<span class="s1">#endif</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">              Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">              Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">              Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_recv( TBUF, Xsize*Ysize*Zsize*nsp,</span>
<span class="s1">     &amp;                       MPI_grid_real, src(icom)-1, 1,</span>
<span class="s1">     &amp;                       MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">#endif</span>

<span class="s1">              J1 = 1</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">              do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                  K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                  do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                    DO NN= 1, NSP</span>
<span class="s1">                      fdst(K1+JS(NN)) = TBUF(J1)</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    ENDDO</span>
<span class="s1">                    K1 = K1 + NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else if (itr.eq.-1) then</span>
<span class="s1">C         From sequencial to clustered</span>
<span class="s1">          NN = 1</span>
<span class="s1">          I3 = 0</span>
<span class="s1">          DO N3=0, NSM-1</span>
<span class="s1">            I2 = 0</span>
<span class="s1">            DO N2= 0, NSM-1</span>
<span class="s1">              I1 = I2 + I3</span>
<span class="s1">              DO N1= 0, NSM-1</span>
<span class="s1">                JS(NN) = I1</span>
<span class="s1">                NN     = NN + 1</span>
<span class="s1">                I1     = I1 + 1</span>
<span class="s1">              ENDDO</span>
<span class="s1">              I2 = I2 + NSRC(1)</span>
<span class="s1">            ENDDO</span>
<span class="s1">            I3 = I3 + NSRC(1)*NSRC(2)</span>
<span class="s1">          ENDDO</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    K1 = (Lbox(1,1) - Dbox(1,1))*NSP + 1 + K2 + K3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        fdst(K1) = fsrc(J1+JS(NN))</span>
<span class="s1">                        K1 = K1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                      J1 = J1 + NSM</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM</span>
<span class="s1">                    K2 = K2 + NDST(1)*NSM*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K1 = 1</span>
<span class="s1">                do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                      DO NN= 1, NSP</span>
<span class="s1">                        TBUF(K1) = fsrc(J1+JS(NN))</span>
<span class="s1">                        K1 = K1 + 1</span>
<span class="s1">                      ENDDO</span>
<span class="s1">                      J1 = J1 + NSM</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)*NSM</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                enddo</span>

<span class="s1">                Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">                Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">                Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call MPI_Send( TBUF, Xsize*Ysize*Zsize*nsp,</span>
<span class="s1">     &amp;                         MPI_grid_real, dst(icom)-1, 1,</span>
<span class="s1">     &amp;                         MPI_Comm_world, MPIerror )</span>
<span class="s1">#endif</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">              Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">              Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">              Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_recv( TBUF, Xsize*Ysize*Zsize*nsp,</span>
<span class="s1">     &amp;                       MPI_grid_real, src(icom)-1, 1,</span>
<span class="s1">     &amp;                       MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">#endif</span>

<span class="s1">              J1 = 1</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">              do I3 = Lbox(1,3), Lbox(2,3)</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM*NSM</span>
<span class="s1">                do I2 = Lbox(1,2), Lbox(2,2)</span>
<span class="s1">                  K1 = (Lbox(1,1) - Dbox(1,1))*NSP + 1 + K2 + K3</span>
<span class="s1">                  do I1 = Lbox(1,1), Lbox(2,1)</span>
<span class="s1">                    DO NN= 1, NSP</span>
<span class="s1">                      fdst(K1) = TBUF(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    ENDDO</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)*NSM*NSM</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)*NSM</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else if (itr.eq.0) then</span>
<span class="s1">C         From sequencial to sequencial or from clustered to clustered</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            Xsize = (Lbox(2,1) - Lbox(1,1) + 1)*NSM</span>
<span class="s1">            Ysize = (Lbox(2,2) - Lbox(1,2) + 1)*NSM</span>
<span class="s1">            Zsize = (Lbox(2,3) - Lbox(1,3) + 1)*NSM</span>
<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">                do I3 = 1, Zsize</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                  do I2 = 1, Ysize</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                    do I1 = 1, Xsize</span>
<span class="s1">                      fdst(K1) = fsrc(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)</span>
<span class="s1">                    K2 = K2 + NDST(1)</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)*NSM</span>
<span class="s1">                K1 = 1</span>
<span class="s1">                do I3 = 1, Zsize</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)*NSM</span>
<span class="s1">                  do I2 = 1, Ysize</span>
<span class="s1">                    J1 = (Lbox(1,1) - Sbox(1,1))*NSM + 1 + J2 + J3</span>
<span class="s1">                    do I1 = 1, Xsize</span>
<span class="s1">                      TBUF(K1) = fsrc(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)</span>
<span class="s1">                enddo</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call MPI_Send( TBUF, Xsize*Ysize*Zsize,</span>
<span class="s1">     &amp;                         MPI_grid_real, dst(icom)-1, 1,</span>
<span class="s1">     &amp;                         MPI_Comm_world, MPIerror )</span>
<span class="s1">#endif</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_recv( TBUF, Xsize*Ysize*Zsize,</span>
<span class="s1">     &amp;                       MPI_grid_real, src(icom)-1, 1,</span>
<span class="s1">     &amp;                       MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">#endif</span>
<span class="s1">              J1 = 1</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)*NSM</span>
<span class="s1">              do I3 = 1, Zsize</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)*NSM</span>
<span class="s1">                do I2 = 1, Ysize</span>
<span class="s1">                  K1 = (Lbox(1,1) - Dbox(1,1))*NSM + 1 + K2 + K3</span>
<span class="s1">                  do I1 = 1, Xsize</span>
<span class="s1">                    fdst(K1) = TBUF(J1)</span>
<span class="s1">                    K1 = K1 + 1</span>
<span class="s1">                    J1 = J1 + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else</span>
<span class="s1">          if (Node.eq.0) then</span>
<span class="s1">            write(*,*)&#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">Wrong</span> <span class="k">parameter </span><span class="n">for</span> <span class="k">function </span><span class="n">distMeshData</span><span class="s1">&#39;</span>
<span class="s1">          endif</span>
<span class="s1">          call die()</span>
<span class="s1">        endif</span>

<span class="s1">        if (MaxSize.gt.0) then</span>
<span class="s1">          call de_alloc( TBUF, &#39;</span><span class="n">TBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        call de_alloc( JS, &#39;</span><span class="n">JS</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      endif</span>

<span class="s1">#ifdef _TRACE_</span>
<span class="s1">      call MPI_Barrier( MPI_Comm_World, MPIerror )</span>
<span class="s1">      call MPItrace_event( 1000, 0 )</span>
<span class="s1">#endif</span>
<span class="s1">      call timer( &#39;</span><span class="n">COMM_BSC</span><span class="s1">&#39;, 2 )</span>
<span class="s1">#ifdef DEBUG</span>
<span class="s1">      call write_debug( &#39;</span>    <span class="n">POS</span> <span class="n">distMeshData</span><span class="s1">&#39; )</span>
<span class="s1">#endif</span>
<span class="s1">!------------------------------------------------------------------------ END</span>
<span class="s1">      end subroutine distMeshData_rea</span>
<span class="s1">#endif</span>

<span class="s1">      subroutine distMeshData_int( iDistr, fsrc, oDistr, fdst, itr )</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">      use mpi_siesta</span>
<span class="s1">#endif</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,  intent(in) :: iDistr, oDistr, itr</span>
<span class="s1">      integer,  intent(in) :: fsrc(*)</span>
<span class="s1">      integer, intent(out) :: fdst(*)</span>

<span class="s1">C     Local variables</span>
<span class="s1">      character(len=*), parameter :: myName = moduName//&#39;</span><span class="n">distMeshData</span> <span class="s1">&#39;</span>
<span class="s1">      character(len=*), parameter :: errMsg = myName//&#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="s1">&#39;</span>
<span class="s1">      integer                     :: I1, I2, I3, J1, J2, J3, K1, K2, K3,</span>
<span class="s1">     &amp;                               ind, ncom, icom, NSRC(3), NDST(3),</span>
<span class="s1">     &amp;                               ME, MaxSize, Xsize, Ysize, Zsize,</span>
<span class="s1">     &amp;                               Lbox(2,3)</span>
<span class="s1">      integer, pointer            :: src(:), dst(:), Sbox(:,:),</span>
<span class="s1">     &amp;                               Dbox(:,:)</span>
<span class="s1">      type(meshDisType),  pointer :: idis, odis</span>
<span class="s1">      logical                     :: inters</span>
<span class="s1">      integer,            pointer :: TBUF(:)</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">      integer                     :: MPIerror, Status(MPI_Status_Size)</span>
<span class="s1">#endif</span>
<span class="s1">!---------------------------------------------------------------------- BEGIN</span>
<span class="s1">      if (nodes == 1) then</span>
<span class="s1">         call die(&quot;Called _int version of distMeshData for n=1&quot;)</span>
<span class="s1">      else</span>
<span class="s1">C       The communications are stored in a triangular structure.</span>
<span class="s1">        if (iDistr.gt.oDistr) then</span>
<span class="s1">          ind  = ((iDistr-1)*(iDistr-2))/2 + oDistr</span>
<span class="s1">          ncom = meshCommu(ind)%ncom</span>
<span class="s1">          src =&gt; meshCommu(ind)%dst</span>
<span class="s1">          dst =&gt; meshCommu(ind)%src</span>
<span class="s1">        else</span>
<span class="s1">          ind = ((oDistr-1)*(oDistr-2))/2 + iDistr</span>
<span class="s1">          ncom = meshCommu(ind)%ncom</span>
<span class="s1">          src =&gt; meshCommu(ind)%src</span>
<span class="s1">          dst =&gt; meshCommu(ind)%dst</span>
<span class="s1">        endif</span>

<span class="s1">        idis =&gt; meshDistr(iDistr)</span>
<span class="s1">        odis =&gt; meshDistr(oDistr)</span>

<span class="s1">        ME  = Node + 1</span>

<span class="s1">C       Compute the maximum size of the buffer needed to transfer data</span>
<span class="s1">C       among the several processes</span>
<span class="s1">        maxSize = 0</span>
<span class="s1">        do icom= 1, ncom</span>
<span class="s1">          if (src(icom).ne.dst(icom)) then</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">            Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">            Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">            MaxSize = max(MaxSize,Xsize*Ysize*Zsize)</span>
<span class="s1">          endif</span>
<span class="s1">        enddo</span>

<span class="s1">        if (MaxSize.gt.0) then</span>
<span class="s1">          nullify( TBUF )</span>
<span class="s1">          call re_alloc( TBUF, 1, MaxSize, &#39;</span><span class="n">TBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>

<span class="s1">        Sbox =&gt; idis%box(:,:,ME)</span>
<span class="s1">        NSRC(1) = Sbox(2,1) - Sbox(1,1) + 1</span>
<span class="s1">        NSRC(2) = Sbox(2,2) - Sbox(1,2) + 1</span>
<span class="s1">        NSRC(3) = Sbox(2,3) - Sbox(1,3) + 1</span>
<span class="s1">        Dbox =&gt; odis%box(:,:,ME)</span>
<span class="s1">        NDST(1) = Dbox(2,1) - Dbox(1,1) + 1</span>
<span class="s1">        NDST(2) = Dbox(2,2) - Dbox(1,2) + 1</span>
<span class="s1">        NDST(3) = Dbox(2,3) - Dbox(1,3) + 1</span>

<span class="s1">        if (itr.eq.0) then</span>
<span class="s1">C         From sequencial to sequencial</span>
<span class="s1">          do icom= 1, ncom</span>
<span class="s1">            Sbox =&gt; idis%box(:,:,src(icom))</span>
<span class="s1">            Dbox =&gt; odis%box(:,:,dst(icom))</span>
<span class="s1">            call boxIntersection( Sbox, Dbox, Lbox, inters )</span>
<span class="s1">            Xsize = Lbox(2,1) - Lbox(1,1) + 1</span>
<span class="s1">            Ysize = Lbox(2,2) - Lbox(1,2) + 1</span>
<span class="s1">            Zsize = Lbox(2,3) - Lbox(1,3) + 1</span>
<span class="s1">            if (src(icom).eq.ME) then</span>
<span class="s1">              if (dst(icom).eq.ME) then</span>
<span class="s1">C               SRC and DST are the current process</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)</span>
<span class="s1">                K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)</span>
<span class="s1">                do I3 = 1, Zsize</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)</span>
<span class="s1">                  K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)</span>
<span class="s1">                  do I2 = 1, Ysize</span>
<span class="s1">                    J1 = Lbox(1,1) - Sbox(1,1) + 1 + J2 + J3</span>
<span class="s1">                    K1 = Lbox(1,1) - Dbox(1,1) + 1 + K2 + K3</span>
<span class="s1">                    do I1 = 1, Xsize</span>
<span class="s1">                      fdst(K1) = fsrc(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)</span>
<span class="s1">                    K2 = K2 + NDST(1)</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)</span>
<span class="s1">                  K3 = K3 + NDST(1)*NDST(2)</span>
<span class="s1">                enddo</span>
<span class="s1">              else</span>
<span class="s1">C               We should send data to process dst(icom)-1</span>
<span class="s1">                J3 = (Lbox(1,3) - Sbox(1,3))*NSRC(1)*NSRC(2)</span>
<span class="s1">                K1 = 1</span>
<span class="s1">                do I3 = 1, Zsize</span>
<span class="s1">                  J2 = (Lbox(1,2) - Sbox(1,2))*NSRC(1)</span>
<span class="s1">                  do I2 = 1, Ysize</span>
<span class="s1">                    J1 = Lbox(1,1) - Sbox(1,1) + 1 + J2 + J3</span>
<span class="s1">                    do I1 = 1, Xsize</span>
<span class="s1">                      TBUF(K1) = fsrc(J1)</span>
<span class="s1">                      K1 = K1 + 1</span>
<span class="s1">                      J1 = J1 + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                    J2 = J2 + NSRC(1)</span>
<span class="s1">                  enddo</span>
<span class="s1">                  J3 = J3 + NSRC(1)*NSRC(2)</span>
<span class="s1">                enddo</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">                call MPI_Send( TBUF, Xsize*Ysize*Zsize,</span>
<span class="s1">     &amp;                         MPI_Integer, dst(icom)-1, 1,</span>
<span class="s1">     &amp;                         MPI_Comm_world, MPIerror )</span>
<span class="s1">#endif</span>
<span class="s1">              endif</span>
<span class="s1">            else</span>
<span class="s1">C             We should receive data from process src(icom)-1</span>
<span class="s1">#ifdef MPI</span>
<span class="s1">              call mpi_recv( TBUF, Xsize*Ysize*Zsize,</span>
<span class="s1">     &amp;                       MPI_Integer, src(icom)-1, 1,</span>
<span class="s1">     &amp;                       MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">#endif</span>
<span class="s1">              J1 = 1</span>
<span class="s1">              K3 = (Lbox(1,3) - Dbox(1,3))*NDST(1)*NDST(2)</span>
<span class="s1">              do I3 = 1, Zsize</span>
<span class="s1">                K2 = (Lbox(1,2) - Dbox(1,2))*NDST(1)</span>
<span class="s1">                do I2 = 1, Ysize</span>
<span class="s1">                  K1 = Lbox(1,1) - Dbox(1,1) + 1 + K2 + K3</span>
<span class="s1">                  do I1 = 1, Xsize</span>
<span class="s1">                    fdst(K1) = TBUF(J1)</span>
<span class="s1">                    K1 = K1 + 1</span>
<span class="s1">                    J1 = J1 + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                  K2 = K2 + NDST(1)</span>
<span class="s1">                enddo</span>
<span class="s1">                K3 = K3 + NDST(1)*NDST(2)</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        else</span>
<span class="s1">          if (Node.eq.0) then</span>
<span class="s1">            write(*,*)&#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">Wrong</span> <span class="k">parameter </span><span class="n">for</span> <span class="k">function </span><span class="n">distMeshData</span><span class="s1">&#39;</span>
<span class="s1">          endif</span>
<span class="s1">          call die()</span>
<span class="s1">        endif</span>

<span class="s1">        if (MaxSize.gt.0) then</span>
<span class="s1">          call de_alloc( TBUF, &#39;</span><span class="n">TBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>
<span class="s1">      endif</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine distMeshData_int</span>

<span class="s1">C ==================================================================</span>
<span class="s1">C Checks if there is an intersection between 2 boxes and, if it exist</span>
<span class="s1">C it returns the resulting box.</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE boxIntersection( ibox1, ibox2, obox, inters )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer ibox1(2,3)       : Input box 1</span>
<span class="s1">C integer ibox2(2,3)       : Input box 2</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C integer obox(2,3)        : Intersection between ibox1 and ibox2</span>
<span class="s1">C logical inters           : TRUE: There is intersection</span>
<span class="s1">C                            FALSE: There is not intersection</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C Checks the three axis of the input boxes to see if there is</span>
<span class="s1">C intersection between the input boxes.</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      subroutine boxIntersection( ibox1, ibox2, obox, inters )</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,  intent(in) :: ibox1(2,3), ibox2(2,3)</span>
<span class="s1">      integer, intent(out) :: obox(2,3)</span>
<span class="s1">      logical, intent(out) :: inters</span>
<span class="s1">C     Local variables</span>
<span class="s1">      integer              :: iaxis</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      inters = .true.</span>
<span class="s1">      do iaxis= 1, 3</span>
<span class="s1">        obox(1,iaxis) = max(ibox1(1,iaxis),ibox2(1,iaxis))</span>
<span class="s1">        obox(2,iaxis) = min(ibox1(2,iaxis),ibox2(2,iaxis))</span>
<span class="s1">        if (obox(2,iaxis).lt.obox(1,iaxis)) inters = .false.</span>
<span class="s1">      enddo</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine boxIntersection</span>

<span class="s1">#ifdef MPI</span>
<span class="s1">      subroutine initMeshExtencil( iDistr, nm )</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C Compute the needed communications in order to send/receive the</span>
<span class="s1">C extencil (when the data is ordered in the distribution iDistr)</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE initMeshExtencil( iDistr, nm )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer iDistr   : Distribution index to be used.</span>
<span class="s1">C integer nm(3)    : Number of Mesh divisions in each cell vector</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C The results are stored in the variable exteCommu(iDistr,1:3) of</span>
<span class="s1">C the current module.</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C For every dimension of the problem, search all the neightbours that</span>
<span class="s1">C we have. Given the current data distribution we compute the limits</span>
<span class="s1">C of our extencil and we check its intersection with all the other </span>
<span class="s1">C processes. Once we know all our neightbours we call subroutine</span>
<span class="s1">C scheduleComm in order to minimize the number of communications steps.</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      use scheComm</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,  intent(in)        :: iDistr, nm(3)</span>
<span class="s1">C     Local variables</span>
<span class="s1">      integer                     :: Ubox(2,3), Lbox(2,3), Ibox(2,3),</span>
<span class="s1">     &amp;                               ii, iaxis, ncom, Gcom, Lcom, P1, P2</span>
<span class="s1">      integer,            pointer :: src(:), dst(:), Dbox(:,:)</span>
<span class="s1">      type(meshDisType),  pointer :: idis</span>
<span class="s1">      type(meshCommType), pointer :: mcomm</span>
<span class="s1">      type(COMM_T)                :: comm</span>
<span class="s1">      logical                     :: inters</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      idis =&gt; meshDistr(iDistr)</span>

<span class="s1">      do iaxis=1, 3</span>
<span class="s1">C       One communication structure for every dimension</span>
<span class="s1">        mcomm =&gt; exteCommu(iDistr,iaxis)</span>

<span class="s1">C       Count the number of communications needed to send/receive</span>
<span class="s1">C       the extencil</span>
<span class="s1">        ncom = 0</span>
<span class="s1">        do P1= 1, Nodes</span>
<span class="s1">C         Create the extencil boxes for both sides of the current</span>
<span class="s1">C         partition</span>
<span class="s1">          Ubox(1:2,1:3) = idis%box(1:2,1:3,P1)</span>
<span class="s1">          Ubox(1,iaxis) = Ubox(1,iaxis) - 1</span>
<span class="s1">          if (Ubox(1,iaxis).lt.1) Ubox(1,iaxis) = nm(iaxis)</span>
<span class="s1">          Ubox(2,iaxis)   = Ubox(1,iaxis)</span>

<span class="s1">          Lbox(1:2,1:3) = idis%box(1:2,1:3,P1)</span>
<span class="s1">          Lbox(2,iaxis) = Lbox(2,iaxis) + 1</span>
<span class="s1">          if (Lbox(2,iaxis).gt.nm(iaxis)) Lbox(2,iaxis) = 1</span>
<span class="s1">          Lbox(1,iaxis) = Lbox(2,iaxis)</span>

<span class="s1">          do P2= P1+1, Nodes</span>
<span class="s1">            Dbox =&gt; idis%box(:,:,P2)</span>
<span class="s1">            call boxIntersection( Dbox, Ubox, Ibox, inters )</span>
<span class="s1">            if (inters) then</span>
<span class="s1">              ncom = ncom + 1</span>
<span class="s1">            else</span>
<span class="s1">              call boxIntersection( Dbox, Lbox, Ibox, inters )</span>
<span class="s1">              if (inters) ncom = ncom + 1</span>
<span class="s1">            endif</span>
<span class="s1">          enddo</span>
<span class="s1">        enddo</span>

<span class="s1">        Gcom = ncom</span>
<span class="s1">C       Create a list of communications needed to send/receive</span>
<span class="s1">C       the extencil</span>
<span class="s1">        if (Gcom.gt.0) then</span>
<span class="s1">          nullify( src, dst )</span>
<span class="s1">          call re_alloc( src, 1, Gcom, &#39;</span><span class="n">src</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">          call re_alloc( dst, 1, Gcom, &#39;</span><span class="n">dst</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>

<span class="s1">          ncom = 0</span>
<span class="s1">          do P1= 1, Nodes</span>
<span class="s1">            Ubox(1:2,1:3) = idis%box(1:2,1:3,P1)</span>
<span class="s1">            Ubox(1,iaxis) = Ubox(1,iaxis) - 1</span>
<span class="s1">            if (Ubox(1,iaxis).lt.1) Ubox(1,iaxis) = nm(iaxis)</span>
<span class="s1">            Ubox(2,iaxis)   = Ubox(1,iaxis)</span>

<span class="s1">            Lbox(1:2,1:3) = idis%box(1:2,1:3,P1)</span>
<span class="s1">            Lbox(2,iaxis) = Lbox(2,iaxis) + 1</span>
<span class="s1">            if (Lbox(2,iaxis).gt.nm(iaxis)) Lbox(2,iaxis) = 1</span>
<span class="s1">            Lbox(1,iaxis) = Lbox(2,iaxis)</span>

<span class="s1">            do P2= P1+1, Nodes</span>
<span class="s1">              Dbox =&gt; idis%box(:,:,P2)</span>
<span class="s1">              call boxIntersection( Dbox, Ubox, Ibox, inters )</span>
<span class="s1">              if (inters) then</span>
<span class="s1">                ncom = ncom + 1</span>
<span class="s1">                src(ncom) = P1</span>
<span class="s1">                dst(ncom) = P2</span>
<span class="s1">              else</span>
<span class="s1">                call boxIntersection( Dbox, Lbox, Ibox, inters )</span>
<span class="s1">                if (inters) then</span>
<span class="s1">                  ncom = ncom + 1</span>
<span class="s1">                  src(ncom) = P1</span>
<span class="s1">                  dst(ncom) = P2</span>
<span class="s1">                endif</span>
<span class="s1">              endif</span>
<span class="s1">            enddo</span>
<span class="s1">          enddo</span>

<span class="s1">          comm%np = Nodes</span>
<span class="s1">C         reschedule the communications in order to minimize the time</span>
<span class="s1">          call scheduleComm( Gcom, src, dst, comm )</span>

<span class="s1">C         Count the number of communications needed by the current process</span>
<span class="s1">          ncom = 0</span>
<span class="s1">          do P1= 1, comm%ncol</span>
<span class="s1">            if (comm%ind(P1,Node+1).ne.0) ncom = ncom + 1</span>
<span class="s1">          enddo</span>
<span class="s1">          Lcom = ncom</span>

<span class="s1">C         Store the ordered list of communications needed by the current</span>
<span class="s1">C         process to send/receive the extencil.</span>
<span class="s1">          if (Lcom.gt.0) then</span>
<span class="s1">            nullify( mcomm%src, mcomm%dst )</span>
<span class="s1">            call re_alloc( mcomm%src, 1, Lcom, &#39;</span><span class="n">mcomm</span><span class="p">%</span><span class="n">src</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                     &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">            call re_alloc( mcomm%dst, 1, Lcom, &#39;</span><span class="n">mcomm</span><span class="p">%</span><span class="n">dst</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                     &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>

<span class="s1">            ncom = 0</span>
<span class="s1">            do P1= 1, comm%ncol</span>
<span class="s1">              ii = comm%ind(P1,Node+1)</span>
<span class="s1">              if (ii.ne.0) then</span>
<span class="s1">                ncom            = ncom + 1</span>
<span class="s1">                mcomm%src(ncom) = src(ii)</span>
<span class="s1">                mcomm%dst(ncom) = dst(ii)</span>
<span class="s1">              endif</span>
<span class="s1">            enddo</span>
<span class="s1">            mcomm%ncom = Lcom</span>

<span class="s1">            call de_alloc( comm%ind, &#39;</span><span class="n">comm</span><span class="p">%</span><span class="n">ind</span><span class="s1">&#39;, &#39;</span><span class="n">scheComm</span><span class="s1">&#39; )</span>
<span class="s1">          endif</span>

<span class="s1">          call de_alloc( dst, &#39;</span><span class="n">dst</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">          call de_alloc( src, &#39;</span><span class="n">src</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">        endif</span>
<span class="s1">      enddo</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine initMeshExtencil</span>

<span class="s1">      subroutine distExtMeshData( iDistr, iaxis, BS, NSM, NN, NSPIN,</span>
<span class="s1">     &amp;                            maxp, NMeshG, dens, BDENS )</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C Send/receive the extencil information from the &quot;dens&quot; matrix to the</span>
<span class="s1">C temporal array &quot;BDENS&quot;.</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE distExtMeshData( iDistr, iaxis, BS, NSM, NN, NSPIN,</span>
<span class="s1">C                             maxp, NMeshG, dens, BDENS )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer iDistr    : Distribution index to be used.</span>
<span class="s1">C integer iaxis     : Axe to be splitted</span>
<span class="s1">C integer BS        : Dimmension of a plane in the current axe</span>
<span class="s1">C integer NSM       : Number of mesh sub-divisions in each direction</span>
<span class="s1">C integer NN        : Size of the extencil</span>
<span class="s1">C integer NSPIN     : Number of pollarizations</span>
<span class="s1">C integer MAXP      : Total number of points</span>
<span class="s1">C integer NMeshG(3) : Number of Mesh points in each cell vector</span>
<span class="s1">C real    DENS      : electron density matrix</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C real    BDENS     : Auxiliar arrays to store the extencil from other</span>
<span class="s1">C                     partitions.</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C Send/receive the extencil information from the &quot;dens&quot; matrix to the</span>
<span class="s1">C temporal array &quot;BDENS&quot;.</span>
<span class="s1">C</span>
<span class="s1">C We have a different code for every axis. We should find if we</span>
<span class="s1">C intersects with a neightbour node throught the upper, the lower</span>
<span class="s1">C or both sides.</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      use mpi_siesta</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,         intent(in) :: iDistr, iaxis, BS, NSM, NN, NSPIN,</span>
<span class="s1">     &amp;                               maxp, NMeshG(3)</span>
<span class="s1">      real(gp),        intent(in) :: DENS(maxp,NSPIN)</span>
<span class="s1">      real(gp),       intent(out) :: BDENS(BS,2*NN,NSPIN)</span>

<span class="s1">C     Local variables</span>
<span class="s1">      integer                     :: Ubox(2,3), Lbox(2,3), IUbox(2,3),</span>
<span class="s1">     &amp;                               ILbox(2,3), nm(3), ispin, Cnode,</span>
<span class="s1">     &amp;                               iniX, endX, iniY, endY, iniZ, endZ,</span>
<span class="s1">     &amp;                               ix, iy, iz, tt, uu, dimB(3), ii, PP</span>
<span class="s1">      logical                     :: inter1, inter2</span>
<span class="s1">      integer,            pointer :: Dbox(:,:)</span>
<span class="s1">      real(gp),           pointer :: SBUF(:), RBUF(:)</span>
<span class="s1">      type(meshDisType),  pointer :: idis</span>
<span class="s1">      type(meshCommType), pointer :: mcomm</span>
<span class="s1">      integer                     :: MPIerror, Status(MPI_Status_Size)</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      idis    =&gt; meshDistr(iDistr)</span>
<span class="s1">      mcomm   =&gt; exteCommu(iDistr,iaxis)</span>
<span class="s1">      nm      = NMeshG/NSM</span>
<span class="s1">      Cnode   = Node + 1</span>
<span class="s1">      dimB(1) = (idis%box(2,1,Cnode)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">      dimB(2) = (idis%box(2,2,Cnode)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">      dimB(3) = (idis%box(2,3,Cnode)-idis%box(1,3,Cnode)+1)*NSM</span>

<span class="s1">      if (.not.associated(mcomm%dst)) then</span>
<span class="s1">        write(6,*) &#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">Trying</span> <span class="n">to</span> <span class="n">communicate</span> <span class="n">extencil</span> <span class="s1">&#39;,</span>
<span class="s1">     &amp;             &#39;</span><span class="n">with</span> <span class="n">an</span> <span class="n">uninitialized</span> <span class="n">mesh</span> <span class="n">distribution</span><span class="s1">&#39;</span>
<span class="s1">        call die()</span>
<span class="s1">      endif</span>
<span class="s1">      if (.not.associated(mcomm%src)) then</span>
<span class="s1">        write(6,*) &#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="n">Trying</span> <span class="n">to</span> <span class="n">communicate</span> <span class="n">extencil</span> <span class="s1">&#39;,</span>
<span class="s1">     &amp;             &#39;</span><span class="n">with</span> <span class="n">an</span> <span class="n">uninitialized</span> <span class="n">mesh</span> <span class="n">distribution</span><span class="s1">&#39;</span>
<span class="s1">        call die()</span>
<span class="s1">      endif</span>

<span class="s1">      nullify(SBUF,RBUF)</span>
<span class="s1">      call re_alloc( SBUF, 1, BS*NN*nspin, &#39;</span><span class="n">SBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      call re_alloc( RBUF, 1, BS*NN*nspin, &#39;</span><span class="n">RBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>

<span class="s1">      Ubox(1:2,1:3) = idis%box(1:2,1:3,Cnode)</span>
<span class="s1">      Ubox(1,iaxis) = Ubox(1,iaxis) - 1</span>
<span class="s1">      if (Ubox(1,iaxis).lt.1) Ubox(1,iaxis) = nm(iaxis)</span>
<span class="s1">      Ubox(2,iaxis)   = Ubox(1,iaxis)</span>

<span class="s1">      Lbox(1:2,1:3) = idis%box(1:2,1:3,Cnode)</span>
<span class="s1">      Lbox(2,iaxis) = Lbox(2,iaxis) + 1</span>
<span class="s1">      if (Lbox(2,iaxis).gt.nm(iaxis)) Lbox(2,iaxis) = 1</span>
<span class="s1">      Lbox(1,iaxis) = Lbox(2,iaxis)</span>

<span class="s1">      do ii= 1, mcomm%ncom</span>
<span class="s1">        if (Cnode.eq.mcomm%src(ii)) then</span>
<span class="s1">          PP = mcomm%dst(ii)</span>
<span class="s1">        else</span>
<span class="s1">          PP = mcomm%src(ii)</span>
<span class="s1">        endif</span>
<span class="s1">        Dbox =&gt; idis%box(:,:,PP)</span>
<span class="s1">        call boxIntersection( Dbox, Ubox, IUbox, inter1 )</span>
<span class="s1">        call boxIntersection( Dbox, Lbox, ILbox, inter2 )</span>
<span class="s1">        if (inter1) then</span>
<span class="s1">          if (iaxis.eq.1) then</span>
<span class="s1">            iniX = 1</span>
<span class="s1">            endX = NN</span>
<span class="s1">            iniY = (IUbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (IUbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (IUbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (IUbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= iniZ, endZ</span>
<span class="s1">                do iy= iniY, endY</span>
<span class="s1">                  uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = dens(uu,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter2) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(2)+iniY</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    do ix= 1, NN</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,NN+ix,ispin) = RBUF(tt)</span>
<span class="s1">                    enddo</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(2)+iniY</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    do ix= NN, 1, -1</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,ix,ispin) = RBUF(tt)</span>
<span class="s1">                    enddo</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          else if (iaxis.eq.2) then</span>
<span class="s1">            iniX = (IUbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (IUbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (IUbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (IUbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= iniZ, endZ</span>
<span class="s1">                do iy= 1, NN</span>
<span class="s1">                  uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = dens(uu,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>

<span class="s1">            if (inter2) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  do iy= 1, NN</span>
<span class="s1">                    uu = (iz-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,NN+iy,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  do iy= NN, 1, -1</span>
<span class="s1">                    uu = (iz-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,iy,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          else</span>
<span class="s1">            iniX = (IUbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (IUbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniY = (IUbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (IUbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= 1, NN</span>
<span class="s1">                do iy= iniY, endY</span>
<span class="s1">                  uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = dens(uu,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>

<span class="s1">            if (inter2) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= 1, NN</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,NN+iz,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= NN, 1, -1</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,iz,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          endif</span>
<span class="s1">        endif</span>

<span class="s1">        if (inter2) then</span>
<span class="s1">          if (iaxis.eq.1) then</span>
<span class="s1">            iniX = dimB(1)-NN+1</span>
<span class="s1">            endX = dimB(1)</span>
<span class="s1">            iniY = (ILbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (ILbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (ILbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (ILbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= iniZ, endZ</span>
<span class="s1">                do iy= iniY, endY</span>
<span class="s1">                  uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = dens(uu,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter1) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(2)+iniY</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    do ix= NN, 1, -1</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,ix,ispin) = RBUF(tt)</span>
<span class="s1">                    enddo</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(2)+iniY</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    do ix= 1, NN</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,NN+ix,ispin) = RBUF(tt)</span>
<span class="s1">                    enddo</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          else if (iaxis.eq.2) then</span>
<span class="s1">            iniX = (ILbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (ILbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (ILbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (ILbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= iniZ, endZ</span>
<span class="s1">                do iy= dimB(2)-NN+1, dimB(2)</span>
<span class="s1">                  uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = dens(uu,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter1) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  do iy= NN, 1, -1</span>
<span class="s1">                    uu = (iz-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,iy,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  do iy= 1, NN</span>
<span class="s1">                    uu = (iz-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,NN+iy,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>

<span class="s1">          else</span>
<span class="s1">            iniX = (ILbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (ILbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniY = (ILbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (ILbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= dimB(3)-NN+1, dimB(3)</span>
<span class="s1">                do iy= iniY, endY</span>
<span class="s1">                  uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = dens(uu,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter1) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= NN, 1, -1</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,iz,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= 1, NN</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      BDENS(uu,NN+iz,ispin) = RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>

<span class="s1">          endif</span>
<span class="s1">        endif</span>
<span class="s1">      enddo</span>

<span class="s1">      call de_alloc( RBUF, &#39;</span><span class="n">RBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      call de_alloc( SBUF, &#39;</span><span class="n">SBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine distExtMeshData</span>


<span class="s1">C ==================================================================</span>
<span class="s1">C Send/receive the extencil information from the &quot;BVXC&quot; temporal array</span>
<span class="s1">C to the array &quot;VXC&quot;.</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE gathExtMeshData( iDistr, iaxis, BS, NSM, NN, NSPIN,</span>
<span class="s1">C                             maxp, NMeshG, BVXC, VXC )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer iDistr    : Distribution index to be used.</span>
<span class="s1">C integer iaxis     : Axe to be splitted</span>
<span class="s1">C integer BS        : Dimmension of a plane in the current axe</span>
<span class="s1">C integer NSM       : Number of mesh sub-divisions in each direction</span>
<span class="s1">C integer NN        : Size of the extencil</span>
<span class="s1">C integer NSPIN     : Number of pollarizations</span>
<span class="s1">C integer MAXP      : Total number of points</span>
<span class="s1">C integer NMeshG(3) : Number of Mesh points in each cell vector</span>
<span class="s1">C real    BVXC      : Auxiliar array that contains the extencil of the</span>
<span class="s1">C                     exch-corr potential</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C real    VXC       : exch-corr potential</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C Send/receive the extencil information from the &quot;BVXC&quot; temporal array</span>
<span class="s1">C to the array &quot;VXC&quot;.</span>
<span class="s1">C</span>
<span class="s1">C We have a different code for every axis. We should find if we</span>
<span class="s1">C intersects with a neightbour node throught the upper, the lower</span>
<span class="s1">C or both sides.</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      subroutine gathExtMeshData( iDistr, iaxis, BS, NSM, NN, NSPIN,</span>
<span class="s1">     &amp;                            maxp, NMeshG, BVXC, VXC )</span>
<span class="s1">      use mpi_siesta</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,         intent(in) :: iDistr, iaxis, BS, NSM, NN, NSPIN,</span>
<span class="s1">     &amp;                               maxp, NMeshG(3)</span>
<span class="s1">      real(gp),        intent(in) :: BVXC(BS,2*NN,NSPIN)</span>
<span class="s1">      real(gp),       intent(out) :: VXC(maxp,NSPIN)</span>
<span class="s1">C     Local variables</span>
<span class="s1">      integer                     :: Ubox(2,3), Lbox(2,3), IUbox(2,3),</span>
<span class="s1">     &amp;                               ILbox(2,3), nm(3), ispin, Cnode,</span>
<span class="s1">     &amp;                               iniX, endX, iniY, endY, iniZ, endZ,</span>
<span class="s1">     &amp;                               ix, iy, iz, tt, uu, dimB(3), ii, PP</span>
<span class="s1">      logical                     :: inter1, inter2</span>
<span class="s1">      integer,            pointer :: Dbox(:,:)</span>
<span class="s1">      real(gp),           pointer :: SBUF(:), RBUF(:)</span>
<span class="s1">      type(meshDisType),  pointer :: idis</span>
<span class="s1">      type(meshCommType), pointer :: mcomm</span>
<span class="s1">      integer                     :: MPIerror, Status(MPI_Status_Size)</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      idis    =&gt; meshDistr(iDistr)</span>
<span class="s1">      mcomm   =&gt; exteCommu(iDistr,iaxis)</span>
<span class="s1">      nm      = NMeshG/NSM</span>
<span class="s1">      Cnode   = Node + 1</span>
<span class="s1">      dimB(1) = (idis%box(2,1,Cnode)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">      dimB(2) = (idis%box(2,2,Cnode)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">      dimB(3) = (idis%box(2,3,Cnode)-idis%box(1,3,Cnode)+1)*NSM</span>

<span class="s1">      nullify(SBUF,RBUF)</span>
<span class="s1">      call re_alloc( SBUF, 1, BS*NN*nspin, &#39;</span><span class="n">SBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      call re_alloc( RBUF, 1, BS*NN*nspin, &#39;</span><span class="n">RBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>

<span class="s1">      Ubox(1:2,1:3) = idis%box(1:2,1:3,Cnode)</span>
<span class="s1">      Ubox(1,iaxis) = Ubox(1,iaxis) - 1</span>
<span class="s1">      if (Ubox(1,iaxis).lt.1) Ubox(1,iaxis) = nm(iaxis)</span>
<span class="s1">      Ubox(2,iaxis)   = Ubox(1,iaxis)</span>

<span class="s1">      Lbox(1:2,1:3) = idis%box(1:2,1:3,Cnode)</span>
<span class="s1">      Lbox(2,iaxis) = Lbox(2,iaxis) + 1</span>
<span class="s1">      if (Lbox(2,iaxis).gt.nm(iaxis)) Lbox(2,iaxis) = 1</span>
<span class="s1">      Lbox(1,iaxis) = Lbox(2,iaxis)</span>

<span class="s1">      do ii= 1, mcomm%ncom</span>
<span class="s1">        if (Cnode.eq.mcomm%src(ii)) then</span>
<span class="s1">          PP = mcomm%dst(ii)</span>
<span class="s1">        else</span>
<span class="s1">          PP = mcomm%src(ii)</span>
<span class="s1">        endif</span>
<span class="s1">        Dbox =&gt; idis%box(:,:,PP)</span>
<span class="s1">        call boxIntersection( Dbox, Ubox, IUbox, inter1 )</span>
<span class="s1">        call boxIntersection( Dbox, Lbox, ILbox, inter2 )</span>
<span class="s1">        if (inter1) then</span>
<span class="s1">          if (iaxis.eq.1) then</span>
<span class="s1">            iniX = 1</span>
<span class="s1">            endX = NN</span>
<span class="s1">            iniY = (IUbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (IUbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (IUbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (IUbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do ix= 1, NN</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(2)+iniY</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = BVXC(uu,ix,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>

<span class="s1">            if (inter2) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do ix= dimB(1), dimB(1)-NN+1, -1</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iniY-1)*dimB(1)+ix</span>
<span class="s1">                    do iy= iniY, endY</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + dimB(1)</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do ix=  1, NN</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iniY-1)*dimB(1)+ix</span>
<span class="s1">                    do iy= iniY, endY</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + dimB(1)</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          else if (iaxis.eq.2) then</span>
<span class="s1">            iniX = (IUbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (IUbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (IUbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (IUbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iy= 1, NN</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = BVXC(uu,iy,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter2) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iy= dimB(2), dimB(2)-NN+1, -1</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iy=  1, NN</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          else</span>
<span class="s1">            iniX = (IUbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (IUbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniY = (IUbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (IUbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= 1, NN</span>
<span class="s1">                do iy= iniY, endY</span>
<span class="s1">                  uu = (iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = BVXC(uu,iz,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter2) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz=  dimB(3), dimB(3)-NN+1, -1</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz=  1, NN</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          endif</span>
<span class="s1">        endif</span>

<span class="s1">        if (inter2) then</span>
<span class="s1">          if (iaxis.eq.1) then</span>
<span class="s1">            iniX = dimB(1)-NN+1</span>
<span class="s1">            endX = dimB(1)</span>
<span class="s1">            iniY = (ILbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (ILbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (ILbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (ILbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do ix= NN+1, 2*NN</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(2)+iniY</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = BVXC(uu,ix,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter1) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do ix=  1, NN</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iniY-1)*dimB(1)+ix</span>
<span class="s1">                    do iy= iniY, endY</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + dimB(1)</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do ix= dimB(1), dimB(1)-NN+1, -1</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iniY-1)*dimB(1)+ix</span>
<span class="s1">                    do iy= iniY, endY</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + dimB(1)</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          else if (iaxis.eq.2) then</span>
<span class="s1">            iniX = (ILbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (ILbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniZ = (ILbox(1,3)-idis%box(1,3,Cnode))*NSM + 1</span>
<span class="s1">            endZ = (ILbox(2,3)-idis%box(1,3,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iy= NN+1, 2*NN</span>
<span class="s1">                do iz= iniZ, endZ</span>
<span class="s1">                  uu = (iz-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = BVXC(uu,iy,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter1) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iy= 1, NN</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iy= dimB(2), dimB(2)-NN+1, -1</span>
<span class="s1">                  do iz= iniZ, endZ</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>

<span class="s1">          else</span>
<span class="s1">            iniX = (ILbox(1,1)-idis%box(1,1,Cnode))*NSM + 1</span>
<span class="s1">            endX = (ILbox(2,1)-idis%box(1,1,Cnode)+1)*NSM</span>
<span class="s1">            iniY = (ILbox(1,2)-idis%box(1,2,Cnode))*NSM + 1</span>
<span class="s1">            endY = (ILbox(2,2)-idis%box(1,2,Cnode)+1)*NSM</span>
<span class="s1">            tt = 0</span>
<span class="s1">            do ispin= 1, nspin</span>
<span class="s1">              do iz= NN+1, 2*NN</span>
<span class="s1">                do iy= iniY, endY</span>
<span class="s1">                  uu = (iy-1)*dimB(1)+iniX</span>
<span class="s1">                  do ix= iniX, endX</span>
<span class="s1">                    tt = tt + 1</span>
<span class="s1">                    SBUF(tt) = BVXC(uu,iz,ispin)</span>
<span class="s1">                    uu = uu + 1</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            enddo</span>
<span class="s1">            call MPI_SendRecv( SBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         RBUF, tt, MPI_grid_real, PP-1, 0,</span>
<span class="s1">     &amp;                         MPI_Comm_world, Status, MPIerror )</span>
<span class="s1">            if (inter1) then</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz=  1, NN</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            else</span>
<span class="s1">              tt = 0</span>
<span class="s1">              do ispin= 1, nspin</span>
<span class="s1">                do iz= dimB(3), dimB(3)-NN+1, -1</span>
<span class="s1">                  do iy= iniY, endY</span>
<span class="s1">                    uu = (iz-1)*dimB(1)*dimB(2)+(iy-1)*dimB(1)+iniX</span>
<span class="s1">                    do ix= iniX, endX</span>
<span class="s1">                      tt = tt + 1</span>
<span class="s1">                      VXC(uu,ispin) = VXC(uu,ispin) + RBUF(tt)</span>
<span class="s1">                      uu = uu + 1</span>
<span class="s1">                    enddo</span>
<span class="s1">                  enddo</span>
<span class="s1">                enddo</span>
<span class="s1">              enddo</span>
<span class="s1">            endif</span>
<span class="s1">          endif</span>
<span class="s1">        endif</span>
<span class="s1">      enddo</span>

<span class="s1">      call de_alloc( RBUF, &#39;</span><span class="n">RBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      call de_alloc( SBUF, &#39;</span><span class="n">SBUF</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">!--------------------------------------------------------------------------- END</span>
<span class="s1">      end subroutine gathExtMeshData</span>

<span class="s1">C ==================================================================</span>
<span class="s1">C Compute the limits of a new distribution, trying to split the load</span>
<span class="s1">C of the array &quot;wload&quot;. We use the nested disection algorithm in</span>
<span class="s1">C order to split the mesh in the 3 dimensions.</span>
<span class="s1">C ==================================================================</span>
<span class="s1">C SUBROUTINE splitwload( Nodes, Node, nm, wload, iDistr, oDistr )</span>
<span class="s1">C</span>
<span class="s1">C INPUT:</span>
<span class="s1">C integer Nodes            : Total number of nodes</span>
<span class="s1">C integer Node             : current Process ID (from 1 to Node)</span>
<span class="s1">C integer NM               : Number of mesh sub-divisions in each direction</span>
<span class="s1">C integer wload            : Weights of every point of the mesh.</span>
<span class="s1">C type(meshDisType) iDistr : Input distribution</span>
<span class="s1">C</span>
<span class="s1">C OUTPUT:</span>
<span class="s1">C type(meshDisType) oDistr : Onput distribution</span>
<span class="s1">C</span>
<span class="s1">C BEHAVIOR:</span>
<span class="s1">C We use the nested disection algorithm to split the load associated</span>
<span class="s1">C to the vector wload among all the processes. The problem is that</span>
<span class="s1">C every process have a different part of wload. Every time that we want</span>
<span class="s1">C to split a piece of the mesh, we should find which processors have that</span>
<span class="s1">C information.</span>
<span class="s1">C wload is a 3D array. In every iteration of the algorithm we should</span>
<span class="s1">C decide the direction of the cut. Then we should made a reduction of</span>
<span class="s1">C this 3-D array to a 1-D array (according to the selected direction).</span>
<span class="s1">C</span>
<span class="s1">C ==================================================================</span>
<span class="s1">      subroutine splitwload( Nodes, Node, nm, wload, iDistr, oDistr )</span>
<span class="s1">      use mpi_siesta</span>
<span class="s1">      implicit none</span>
<span class="s1">C     Passed arguments</span>
<span class="s1">      integer,      intent(in)      :: Nodes, Node, nm(3), wload(*)</span>
<span class="s1">      type(meshDisType),intent(in)  :: iDistr</span>
<span class="s1">      type(meshDisType),intent(out) :: oDistr</span>
<span class="s1">C     Local variables</span>
<span class="s1">      character(len=*), parameter :: myName = moduName//&#39;</span><span class="n">splitwload</span> <span class="s1">&#39;</span>
<span class="s1">      character(len=*), parameter :: errMsg = myName//&#39;</span><span class="n">ERROR</span><span class="p">:</span> <span class="s1">&#39;</span>
<span class="s1">      integer                     :: PP, Lbox(2,3), Ldim,</span>
<span class="s1">     &amp;                               QQ, P1, P2, POS, ini</span>
<span class="s1">      integer(i8b),          pointer :: lwload(:), gwload(:), recvB(:)</span>
<span class="s1">      logical                     :: found, inters</span>
<span class="s1">      integer                     :: mGdim, mLdim, nAxis, nms(3)</span>
<span class="s1">      integer(i8b)                   :: h1, h2</span>
<span class="s1">      integer,            pointer :: PROCS(:)</span>
<span class="s1">      integer                     :: MPIerror, Status(MPI_Status_Size)</span>
<span class="s1">!------------------------------------------------------------------------- BEGIN</span>
<span class="s1">      call timer( &#39;</span><span class="n">SPLOAD</span><span class="s1">&#39;, 1 )</span>

<span class="s1">C     At the begining of the algorithm all the mesh is assigned to the</span>
<span class="s1">C     first node:  oDistr%box(*,*,1) = nm</span>
<span class="s1">      oDistr%box(1,1,1) = 1</span>
<span class="s1">      oDistr%box(2,1,1) = nm(1)</span>
<span class="s1">      oDistr%box(1,2,1) = 1</span>
<span class="s1">      oDistr%box(2,2,1) = nm(2)</span>
<span class="s1">      oDistr%box(1,3,1) = 1</span>
<span class="s1">      oDistr%box(2,3,1) = nm(3)</span>
<span class="s1">      oDistr%box(1:2,1:3,2:Nodes) = 0</span>

<span class="s1">      nms = nm</span>

<span class="s1">C     Array PROCS will contain the number of processes that are associated to</span>
<span class="s1">C     every box. At the begining all the mesh is assigned to process 1, then</span>
<span class="s1">C     PROCS(1)=Nodes, while the rest are equal to zero</span>
<span class="s1">      nullify( PROCS, lwload, gwload, recvB )</span>
<span class="s1">      call re_alloc( PROCS, 1, Nodes, &#39;</span><span class="n">PROCS</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">      PROCS(1)       = Nodes</span>
<span class="s1">      PROCS(2:Nodes) = 0</span>

<span class="s1">      found = .true.</span>
<span class="s1">      do while(found)</span>
<span class="s1">C       Choose the direction to cut the mesh</span>
<span class="s1">        nAxis = 3</span>
<span class="s1">        if (nms(2).gt.nms(nAxis)) nAxis = 2</span>
<span class="s1">        if (nms(1).gt.nms(nAxis)) nAxis = 1</span>
<span class="s1">        nms(nAxis) = (nms(nAxis)+1)/2</span>

<span class="s1">C       Check if we still have to keep cutting the mesh</span>
<span class="s1">        found = .false.</span>
<span class="s1">        do PP=Nodes, 1, -1</span>
<span class="s1">          if (PROCS(PP).GT.1) then</span>
<span class="s1">C           There are more than one processes associated to the mesh</span>
<span class="s1">C           of process PP. We are going to split the mesh in two parts</span>
<span class="s1">C           of p1 and p2 processors.</span>
<span class="s1">            p1 = PROCS(PP)/2</span>
<span class="s1">            p2 = PROCS(PP) - p1</span>
<span class="s1">            found = .true.</span>
<span class="s1">C           Check if the current partition has intersection with the piece of</span>
<span class="s1">C           mesh that we want to cut.</span>
<span class="s1">            call boxIntersection( oDistr%box(:,:,PP),</span>
<span class="s1">     &amp;                            iDistr%box(:,:,Node),</span>
<span class="s1">     &amp;                            Lbox, inters )</span>
<span class="s1">            if (Node.eq.PP) then</span>
<span class="s1">              mGdim = oDistr%box(2,nAxis,PP)-oDistr%box(1,nAxis,PP)+1</span>

<span class="s1">              call re_alloc( gwload, 1, mGdim, &#39;</span><span class="n">gwload</span><span class="s1">&#39;,&#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">              call re_alloc( recvB, 1, mGdim, &#39;</span><span class="n">recvB</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">            endif</span>

<span class="s1">            if (inters) then</span>
<span class="s1">C             If there is an intersection I should reduce the intersected part</span>
<span class="s1">C             from a 3-D array to a 1-D array.</span>
<span class="s1">              mLdim = Lbox(2,nAxis) - Lbox(1,nAxis) + 1</span>
<span class="s1">              call re_alloc( lwload, 1, mLdim, &#39;</span><span class="n">lwload</span><span class="s1">&#39;,</span>
<span class="s1">     &amp;                       &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39; )</span>
<span class="s1">              call reduce3Dto1D( nAxis, iDistr%box(:,:,Node), Lbox,</span>
<span class="s1">     &amp;                           wload, lwload )</span>
<span class="s1">            endif</span>
<span class="s1">            if (Node.eq.PP) then</span>
<span class="s1">C             If, I&#39;</span><span class="n">m</span> <span class="n">the</span> <span class="n">process</span> <span class="n">PP</span> <span class="n">I</span> <span class="n">should</span> <span class="n">receive</span> <span class="n">the</span> <span class="n">information</span> <span class="n">from</span> <span class="n">other</span>
<span class="n">C</span>             <span class="n">processes</span>
              <span class="n">gwload</span> <span class="o">=</span> <span class="mi">0</span>
              <span class="k">do </span><span class="n">QQ</span><span class="o">=</span> <span class="mi">1</span><span class="p">,</span> <span class="n">Nodes</span>
                <span class="k">call </span><span class="n">boxIntersection</span><span class="p">(</span> <span class="n">oDistr</span><span class="p">%</span><span class="n">box</span><span class="p">(:,:,</span><span class="n">PP</span><span class="p">),</span>
     <span class="p">&amp;</span>                                <span class="n">iDistr</span><span class="p">%</span><span class="n">box</span><span class="p">(:,:,</span><span class="n">QQ</span><span class="p">),</span>
     <span class="p">&amp;</span>                                <span class="n">Lbox</span><span class="p">,</span> <span class="n">inters</span> <span class="p">)</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">inters</span><span class="p">)</span> <span class="k">then</span>
<span class="k">                  </span><span class="n">Ldim</span> <span class="o">=</span> <span class="n">Lbox</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="n">nAxis</span><span class="p">)</span> <span class="o">-</span> <span class="n">Lbox</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nAxis</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                  <span class="n">ini</span>  <span class="o">=</span> <span class="n">Lbox</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nAxis</span><span class="p">)</span> <span class="o">-</span> <span class="n">oDistr</span><span class="p">%</span><span class="n">box</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="n">nAxis</span><span class="p">,</span><span class="n">PP</span><span class="p">)</span>
                  <span class="k">if</span> <span class="p">(</span><span class="n">PP</span><span class="p">.</span><span class="n">eq</span><span class="p">.</span><span class="n">QQ</span><span class="p">)</span> <span class="k">then</span>
<span class="k">                    </span><span class="n">gwload</span><span class="p">(</span><span class="n">ini</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ini</span><span class="o">+</span><span class="n">Ldim</span><span class="p">)</span> <span class="o">=</span> 
     <span class="p">&amp;</span>              <span class="n">gwload</span><span class="p">(</span><span class="n">ini</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ini</span><span class="o">+</span><span class="n">Ldim</span><span class="p">)</span> <span class="o">+</span> <span class="n">lwload</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">Ldim</span><span class="p">)</span>
                  <span class="k">else</span>
<span class="k">                    call </span><span class="n">mpi_recv</span><span class="p">(</span> <span class="n">recvB</span><span class="p">,</span> <span class="n">Ldim</span><span class="p">,</span> <span class="n">MPI_INTEGER8</span><span class="p">,</span> <span class="n">QQ</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
     <span class="p">&amp;</span>                             <span class="n">MPI_Comm_world</span><span class="p">,</span> <span class="n">Status</span><span class="p">,</span> <span class="n">MPIerror</span> <span class="p">)</span>
                    <span class="n">gwload</span><span class="p">(</span><span class="n">ini</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ini</span><span class="o">+</span><span class="n">Ldim</span><span class="p">)</span> <span class="o">=</span>
     <span class="p">&amp;</span>              <span class="n">gwload</span><span class="p">(</span><span class="n">ini</span><span class="o">+</span><span class="mi">1</span><span class="p">:</span><span class="n">ini</span><span class="o">+</span><span class="n">Ldim</span><span class="p">)</span> <span class="o">+</span> <span class="n">recvB</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">Ldim</span><span class="p">)</span>
                  <span class="n">endif</span>
                <span class="n">endif</span>
              <span class="n">enddo</span>
              <span class="k">call </span><span class="n">de_alloc</span><span class="p">(</span> <span class="n">recvB</span><span class="p">,</span> <span class="s1">&#39;recvB&#39;</span><span class="p">,</span> <span class="s1">&#39;moreMeshSubs&#39;</span> <span class="p">)</span>

<span class="n">C</span>             <span class="n">Process</span> <span class="n">PP</span> <span class="n">computes</span> <span class="k">where </span><span class="n">to</span> <span class="n">cut</span> <span class="n">the</span> <span class="n">mesh</span>
              <span class="k">call </span><span class="n">vecBisec</span><span class="p">(</span> <span class="n">mGdim</span><span class="p">,</span> <span class="n">gwload</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span><span class="n">mGdim</span><span class="p">),</span>
     <span class="p">&amp;</span>                        <span class="n">PROCS</span><span class="p">(</span><span class="n">PP</span><span class="p">),</span> <span class="n">POS</span><span class="p">,</span> <span class="n">h1</span><span class="p">,</span> <span class="n">h2</span> <span class="p">)</span>
              <span class="k">call </span><span class="n">de_alloc</span><span class="p">(</span><span class="n">gwload</span><span class="p">,</span> <span class="s1">&#39;gwload&#39;</span><span class="p">,</span> <span class="s1">&#39;moreMeshSubs&#39;</span><span class="p">)</span>

            <span class="k">else if</span> <span class="p">(</span><span class="n">inters</span><span class="p">)</span> <span class="k">then</span>
<span class="n">C</span>             <span class="k">If</span><span class="p">,</span> <span class="n">I</span><span class="s1">&#39;m not the process PP I should send the information to</span>
<span class="s1">C             the process PP</span>
<span class="s1">              call MPI_Send( lwload, mLdim,</span>
<span class="s1">     &amp;                       MPI_INTEGER8, PP-1, 1, MPI_Comm_World,</span>
<span class="s1">     &amp;                       MPIerror )</span>
<span class="s1">            endif</span>

<span class="s1">            if (associated(lwload))</span>
<span class="s1">     &amp;        call de_alloc(lwload, &#39;</span><span class="n">lwload</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39;)</span>

<span class="s1">C           Process PP send the position of the cut to the rest of processes</span>
<span class="s1">            call MPI_Bcast( pos, 1, MPI_integer, PP-1,</span>
<span class="s1">     &amp;                      MPI_Comm_World, MPIerror )</span>

<span class="s1">C           We have splitted the piece of mesh associated to process PP</span>
<span class="s1">C           in two parts. One would be stored in position PP and the other</span>
<span class="s1">C           would be stored in position PP+P1</span>
<span class="s1">            QQ                     = PP + P1</span>
<span class="s1">            oDistr%box(1:2,1:3,QQ) = oDistr%box(1:2,1:3,PP)</span>
<span class="s1">            pos                    = oDistr%box(1,naxis,QQ) + pos</span>
<span class="s1">            oDistr%box(1,naxis,QQ) = pos</span>
<span class="s1">            oDistr%box(2,naxis,PP) = pos - 1</span>
<span class="s1">C           We should actualize the numbers of processes associated to PP and QQ</span>
<span class="s1">            PROCS(PP)              = P1</span>
<span class="s1">            PROCS(QQ)              = P2</span>
<span class="s1">          endif</span>
<span class="s1">        enddo</span>
<span class="s1">      enddo</span>

<span class="s1">      call de_alloc( PROCS, &#39;</span><span class="n">PROCS</span><span class="s1">&#39;, &#39;</span><span class="n">moreMeshSubs</span><span class="s1">&#39;)</span>
<span class="s1">      call timer( &#39;</span><span class="n">SPLOAD</span><span class="err">&#39;</span><span class="p">,</span> <span class="mi">2</span> <span class="p">)</span>
<span class="c">!--------------------------------------------------------------------------- END</span>
      <span class="k">end subroutine </span><span class="n">splitwload</span>
</pre></div>

    </section>
    <br>
    
    
    </div>
  </div>


    <hr>    
    </div> <!-- /container -->
    <footer>
      <div class="container">
      <div class="row">
        <div class="col-xs-6 col-md-4"><p>&copy; 2018 <a rel="license" href="http://www.gnu.org/licenses/old-licenses/fdl-1.2.en.html">GNU Free Documentation License</a>
                                          </p></div>
        <div class="col-xs-6 col-md-4 col-md-push-4">
          <p class="text-right">
            Documentation generated by 
            <a href="https://github.com/cmacmackin/ford">FORD</a>
            
          </p>
        </div>
        <div class="col-xs-12 col-md-4 col-md-pull-4"><p class="text-center"> SIESTA was developed by SIESTA Group</p></div>
      </div>
      <br>
      </div> <!-- /container -->    
    </footer>

    <!-- Bootstrap core JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
<!--
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.1/jquery.min.js"></script>
-->
    <script src="../js/bootstrap.min.js"></script>
    <!-- IE10 viewport hack for Surface/desktop Windows 8 bug -->
    <script src="../js/ie10-viewport-bug-workaround.js"></script>

    <!-- MathJax JavaScript
    ================================================== -->
    <!-- Placed at the end of the document so the pages load faster -->
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'AMS' } },
        jax: ['input/TeX','input/MathML','output/HTML-CSS'],
        extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']
      });
    </script>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    
    
  </body>
</html>